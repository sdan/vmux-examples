{"version":3,"file":"index.js","names":["createOpencodeClient: unknown","env: Record<string, string>"],"sources":["../../src/opencode/types.ts","../../src/opencode/opencode.ts"],"sourcesContent":["import type { Config } from '@opencode-ai/sdk';\nimport { ErrorCode, type OpencodeStartupContext } from '@repo/shared/errors';\n\n/**\n * Configuration options for starting OpenCode server\n */\nexport interface OpencodeOptions {\n  /** Port for OpenCode server (default: 4096) */\n  port?: number;\n  /** Working directory for OpenCode (default: container's cwd) */\n  directory?: string;\n  /** OpenCode configuration */\n  config?: Config;\n}\n\n/**\n * Server lifecycle management\n */\nexport interface OpencodeServer {\n  /** Port the server is running on */\n  port: number;\n  /** Base URL for SDK client (http://localhost:{port}) */\n  url: string;\n  /** Close the server gracefully */\n  close(): Promise<void>;\n}\n\n/**\n * Result from createOpencode()\n * Client type comes from @opencode-ai/sdk (user's version)\n */\nexport interface OpencodeResult<TClient = unknown> {\n  /** OpenCode SDK client with Sandbox transport */\n  client: TClient;\n  /** Server lifecycle management */\n  server: OpencodeServer;\n}\n\n/**\n * Error thrown when OpenCode server fails to start\n */\nexport class OpencodeStartupError extends Error {\n  public readonly code = ErrorCode.OPENCODE_STARTUP_FAILED;\n  public readonly context: OpencodeStartupContext;\n\n  constructor(\n    message: string,\n    context: OpencodeStartupContext,\n    options?: ErrorOptions\n  ) {\n    super(message, options);\n    this.name = 'OpencodeStartupError';\n    this.context = context;\n  }\n}\n","import type { Config } from '@opencode-ai/sdk';\nimport { createLogger, type Logger, type Process } from '@repo/shared';\nimport type { Sandbox } from '../sandbox';\nimport type { OpencodeOptions, OpencodeResult, OpencodeServer } from './types';\nimport { OpencodeStartupError } from './types';\n\n// Lazy logger creation to avoid global scope restrictions in Workers\nfunction getLogger(): Logger {\n  return createLogger({ component: 'sandbox-do', operation: 'opencode' });\n}\n\nconst DEFAULT_PORT = 4096;\nconst OPENCODE_SERVE = (port: number) =>\n  `opencode serve --port ${port} --hostname 0.0.0.0`;\n\n/**\n * Build the full command, optionally with a directory prefix.\n * If directory is provided, we cd to it first so OpenCode uses it as cwd.\n */\nfunction buildOpencodeCommand(port: number, directory?: string): string {\n  const serve = OPENCODE_SERVE(port);\n  return directory ? `cd ${directory} && ${serve}` : serve;\n}\n\n// Dynamic import to handle peer dependency\n// Using unknown since SDK is optional peer dep - cast at usage site\nlet createOpencodeClient: unknown;\n\nasync function ensureSdkLoaded(): Promise<void> {\n  if (createOpencodeClient) return;\n\n  try {\n    const sdk = await import('@opencode-ai/sdk');\n    createOpencodeClient = sdk.createOpencodeClient;\n  } catch {\n    throw new Error(\n      '@opencode-ai/sdk is required for OpenCode integration. ' +\n        'Install it with: npm install @opencode-ai/sdk'\n    );\n  }\n}\n\n/**\n * Find an existing OpenCode server process running on the specified port.\n * Returns the process if found and still active, null otherwise.\n * Matches by the serve command pattern since directory prefix may vary.\n */\nasync function findExistingOpencodeProcess(\n  sandbox: Sandbox<unknown>,\n  port: number\n): Promise<Process | null> {\n  const processes = await sandbox.listProcesses();\n  const serveCommand = OPENCODE_SERVE(port);\n\n  for (const proc of processes) {\n    // Match commands that contain the serve command (with or without cd prefix)\n    if (proc.command.includes(serveCommand)) {\n      if (proc.status === 'starting' || proc.status === 'running') {\n        return proc;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Ensures OpenCode server is running in the container.\n * Reuses existing process if one is already running on the specified port.\n * Handles concurrent startup attempts gracefully by retrying on failure.\n * Returns the process handle.\n */\nasync function ensureOpencodeServer(\n  sandbox: Sandbox<unknown>,\n  port: number,\n  directory?: string,\n  config?: Config\n): Promise<Process> {\n  // Check if OpenCode is already running on this port\n  const existingProcess = await findExistingOpencodeProcess(sandbox, port);\n  if (existingProcess) {\n    // Reuse existing process - wait for it to be ready if still starting\n    if (existingProcess.status === 'starting') {\n      getLogger().debug('Found starting OpenCode process, waiting for ready', {\n        port,\n        processId: existingProcess.id\n      });\n      try {\n        await existingProcess.waitForPort(port, {\n          mode: 'http',\n          path: '/',\n          timeout: 60_000\n        });\n      } catch (e) {\n        const logs = await existingProcess.getLogs();\n        throw new OpencodeStartupError(\n          `OpenCode server failed to start. Stderr: ${logs.stderr || '(empty)'}`,\n          { port, stderr: logs.stderr, command: existingProcess.command },\n          { cause: e }\n        );\n      }\n    }\n    getLogger().debug('Reusing existing OpenCode process', {\n      port,\n      processId: existingProcess.id\n    });\n    return existingProcess;\n  }\n\n  // Try to start a new OpenCode server\n  try {\n    return await startOpencodeServer(sandbox, port, directory, config);\n  } catch (startupError) {\n    // Startup failed - check if another concurrent request started the server\n    // This handles the race condition where multiple requests try to start simultaneously\n    const retryProcess = await findExistingOpencodeProcess(sandbox, port);\n    if (retryProcess) {\n      getLogger().debug(\n        'Startup failed but found concurrent process, reusing',\n        {\n          port,\n          processId: retryProcess.id\n        }\n      );\n      // Wait for the concurrent server to be ready\n      if (retryProcess.status === 'starting') {\n        try {\n          await retryProcess.waitForPort(port, {\n            mode: 'http',\n            path: '/',\n            timeout: 60_000\n          });\n        } catch (e) {\n          const logs = await retryProcess.getLogs();\n          throw new OpencodeStartupError(\n            `OpenCode server failed to start. Stderr: ${logs.stderr || '(empty)'}`,\n            { port, stderr: logs.stderr, command: retryProcess.command },\n            { cause: e }\n          );\n        }\n      }\n      return retryProcess;\n    }\n\n    // No concurrent server found - the failure was genuine\n    throw startupError;\n  }\n}\n\n/**\n * Internal function to start a new OpenCode server process.\n */\nasync function startOpencodeServer(\n  sandbox: Sandbox<unknown>,\n  port: number,\n  directory?: string,\n  config?: Config\n): Promise<Process> {\n  getLogger().info('Starting OpenCode server', { port, directory });\n\n  // Pass config via OPENCODE_CONFIG_CONTENT and also extract API keys to env vars\n  // because OpenCode's provider auth looks for env vars like ANTHROPIC_API_KEY\n  const env: Record<string, string> = {};\n\n  if (config) {\n    env.OPENCODE_CONFIG_CONTENT = JSON.stringify(config);\n\n    // Extract API keys from provider config\n    // Support both options.apiKey (official type) and legacy top-level apiKey\n    if (\n      config.provider &&\n      typeof config.provider === 'object' &&\n      !Array.isArray(config.provider)\n    ) {\n      for (const [providerId, providerConfig] of Object.entries(\n        config.provider\n      )) {\n        // Try options.apiKey first (official Config type)\n        let apiKey = providerConfig?.options?.apiKey;\n        // Fall back to top-level apiKey for convenience\n        if (!apiKey) {\n          apiKey = (providerConfig as Record<string, unknown> | undefined)\n            ?.apiKey as string | undefined;\n        }\n        if (typeof apiKey === 'string') {\n          const envVar = `${providerId.toUpperCase()}_API_KEY`;\n          env[envVar] = apiKey;\n        }\n      }\n    }\n  }\n\n  const command = buildOpencodeCommand(port, directory);\n  const process = await sandbox.startProcess(command, {\n    env: Object.keys(env).length > 0 ? env : undefined\n  });\n\n  // Wait for server to be ready\n  try {\n    await process.waitForPort(port, {\n      mode: 'http',\n      path: '/',\n      timeout: 60_000\n    });\n    getLogger().info('OpenCode server started successfully', {\n      port,\n      processId: process.id\n    });\n  } catch (e) {\n    const logs = await process.getLogs();\n    const error = e instanceof Error ? e : undefined;\n    getLogger().error('OpenCode server failed to start', error, {\n      port,\n      stderr: logs.stderr\n    });\n    throw new OpencodeStartupError(\n      `OpenCode server failed to start. Stderr: ${logs.stderr || '(empty)'}`,\n      { port, stderr: logs.stderr, command },\n      { cause: e }\n    );\n  }\n\n  return process;\n}\n\n/**\n * Starts an OpenCode server inside a Sandbox container.\n *\n * This function manages the server lifecycle only - use `createOpencode()` if you\n * also need a typed SDK client for programmatic access.\n *\n * If an OpenCode server is already running on the specified port, this function\n * will reuse it instead of starting a new one.\n *\n * @param sandbox - The Sandbox instance to run OpenCode in\n * @param options - Configuration options\n * @returns Promise resolving to server handle { port, url, close() }\n *\n * @example\n * ```typescript\n * import { getSandbox } from '@cloudflare/sandbox'\n * import { createOpencodeServer } from '@cloudflare/sandbox/opencode'\n *\n * const sandbox = getSandbox(env.Sandbox, 'my-agent')\n * const server = await createOpencodeServer(sandbox, {\n *   directory: '/home/user/my-project',\n *   config: { provider: { anthropic: { options: { apiKey: env.ANTHROPIC_KEY } } } }\n * })\n *\n * // Proxy requests to the web UI\n * return sandbox.containerFetch(request, server.port)\n *\n * // When done\n * await server.close()\n * ```\n */\nexport async function createOpencodeServer(\n  sandbox: Sandbox<unknown>,\n  options?: OpencodeOptions\n): Promise<OpencodeServer> {\n  const port = options?.port ?? DEFAULT_PORT;\n  const process = await ensureOpencodeServer(\n    sandbox,\n    port,\n    options?.directory,\n    options?.config\n  );\n\n  return {\n    port,\n    url: `http://localhost:${port}`,\n    close: () => process.kill('SIGTERM')\n  };\n}\n\n/**\n * Creates an OpenCode server inside a Sandbox container and returns a typed SDK client.\n *\n * This function is API-compatible with OpenCode's own createOpencode(), but uses\n * Sandbox process management instead of Node.js spawn. The returned client uses\n * a custom fetch adapter to route requests through the Sandbox container.\n *\n * If an OpenCode server is already running on the specified port, this function\n * will reuse it instead of starting a new one.\n *\n * @param sandbox - The Sandbox instance to run OpenCode in\n * @param options - Configuration options\n * @returns Promise resolving to { client, server }\n *\n * @example\n * ```typescript\n * import { getSandbox } from '@cloudflare/sandbox'\n * import { createOpencode } from '@cloudflare/sandbox/opencode'\n *\n * const sandbox = getSandbox(env.Sandbox, 'my-agent')\n * const { client, server } = await createOpencode(sandbox, {\n *   directory: '/home/user/my-project',\n *   config: { provider: { anthropic: { options: { apiKey: env.ANTHROPIC_KEY } } } }\n * })\n *\n * // Use the SDK client for programmatic access\n * const session = await client.session.create()\n *\n * // When done\n * await server.close()\n * ```\n */\nexport async function createOpencode<TClient = unknown>(\n  sandbox: Sandbox<unknown>,\n  options?: OpencodeOptions\n): Promise<OpencodeResult<TClient>> {\n  await ensureSdkLoaded();\n\n  const server = await createOpencodeServer(sandbox, options);\n\n  // Create SDK client with Sandbox transport\n  // Cast from unknown - SDK is optional peer dependency loaded dynamically\n  const clientFactory = createOpencodeClient as (options: {\n    baseUrl: string;\n    fetch: (request: Request) => Promise<Response>;\n  }) => TClient;\n\n  const client = clientFactory({\n    baseUrl: server.url,\n    fetch: (request: Request) => sandbox.containerFetch(request, server.port)\n  });\n\n  return { client, server };\n}\n\n/**\n * Proxy a request to the OpenCode web UI.\n *\n * This function handles the redirect and proxying only - you must start the\n * server separately using `createOpencodeServer()`.\n *\n * Specifically handles:\n * 1. Ensuring the `?url=` parameter is set (required for OpenCode's frontend to\n *    make API calls through the proxy instead of directly to localhost:4096)\n * 2. Proxying the request to the container\n *\n * @param request - The incoming HTTP request\n * @param sandbox - The Sandbox instance running OpenCode\n * @param server - The OpenCode server handle from createOpencodeServer()\n * @returns Response from OpenCode or a redirect response\n *\n * @example\n * ```typescript\n * import { getSandbox } from '@cloudflare/sandbox'\n * import { createOpencodeServer, proxyToOpencode } from '@cloudflare/sandbox/opencode'\n *\n * export default {\n *   async fetch(request: Request, env: Env) {\n *     const sandbox = getSandbox(env.Sandbox, 'opencode')\n *     const server = await createOpencodeServer(sandbox, {\n *       directory: '/home/user/project',\n *       config: { provider: { anthropic: { options: { apiKey: env.ANTHROPIC_KEY } } } }\n *     })\n *     return proxyToOpencode(request, sandbox, server)\n *   }\n * }\n * ```\n */\nexport function proxyToOpencode(\n  request: Request,\n  sandbox: Sandbox<unknown>,\n  server: OpencodeServer\n): Response | Promise<Response> {\n  const url = new URL(request.url);\n\n  // OpenCode's frontend defaults to http://127.0.0.1:4096 when hostname includes\n  // \"localhost\" or \"opencode.ai\". The ?url= parameter overrides this behavior.\n  // We only redirect GET requests for HTML pages (initial page load).\n  // API calls (POST, PATCH, etc.) and asset requests are proxied directly\n  // since redirecting POST loses the request body.\n  if (!url.searchParams.has('url') && request.method === 'GET') {\n    const accept = request.headers.get('accept') || '';\n    const isHtmlRequest = accept.includes('text/html') || url.pathname === '/';\n    if (isHtmlRequest) {\n      url.searchParams.set('url', url.origin);\n      return Response.redirect(url.toString(), 302);\n    }\n  }\n\n  return sandbox.containerFetch(request, server.port);\n}\n"],"mappings":"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"}