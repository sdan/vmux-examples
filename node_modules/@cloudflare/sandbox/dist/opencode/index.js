import { l as createLogger } from "../dist-c_xYW5i_.js";
import { t as ErrorCode } from "../errors-BCXUmJUn.js";

//#region src/opencode/types.ts
/**
* Error thrown when OpenCode server fails to start
*/
var OpencodeStartupError = class extends Error {
	code = ErrorCode.OPENCODE_STARTUP_FAILED;
	context;
	constructor(message, context, options) {
		super(message, options);
		this.name = "OpencodeStartupError";
		this.context = context;
	}
};

//#endregion
//#region src/opencode/opencode.ts
function getLogger() {
	return createLogger({
		component: "sandbox-do",
		operation: "opencode"
	});
}
const DEFAULT_PORT = 4096;
const OPENCODE_SERVE = (port) => `opencode serve --port ${port} --hostname 0.0.0.0`;
/**
* Build the full command, optionally with a directory prefix.
* If directory is provided, we cd to it first so OpenCode uses it as cwd.
*/
function buildOpencodeCommand(port, directory) {
	const serve = OPENCODE_SERVE(port);
	return directory ? `cd ${directory} && ${serve}` : serve;
}
let createOpencodeClient;
async function ensureSdkLoaded() {
	if (createOpencodeClient) return;
	try {
		createOpencodeClient = (await import("@opencode-ai/sdk")).createOpencodeClient;
	} catch {
		throw new Error("@opencode-ai/sdk is required for OpenCode integration. Install it with: npm install @opencode-ai/sdk");
	}
}
/**
* Find an existing OpenCode server process running on the specified port.
* Returns the process if found and still active, null otherwise.
* Matches by the serve command pattern since directory prefix may vary.
*/
async function findExistingOpencodeProcess(sandbox, port) {
	const processes = await sandbox.listProcesses();
	const serveCommand = OPENCODE_SERVE(port);
	for (const proc of processes) if (proc.command.includes(serveCommand)) {
		if (proc.status === "starting" || proc.status === "running") return proc;
	}
	return null;
}
/**
* Ensures OpenCode server is running in the container.
* Reuses existing process if one is already running on the specified port.
* Handles concurrent startup attempts gracefully by retrying on failure.
* Returns the process handle.
*/
async function ensureOpencodeServer(sandbox, port, directory, config) {
	const existingProcess = await findExistingOpencodeProcess(sandbox, port);
	if (existingProcess) {
		if (existingProcess.status === "starting") {
			getLogger().debug("Found starting OpenCode process, waiting for ready", {
				port,
				processId: existingProcess.id
			});
			try {
				await existingProcess.waitForPort(port, {
					mode: "http",
					path: "/",
					timeout: 6e4
				});
			} catch (e) {
				const logs = await existingProcess.getLogs();
				throw new OpencodeStartupError(`OpenCode server failed to start. Stderr: ${logs.stderr || "(empty)"}`, {
					port,
					stderr: logs.stderr,
					command: existingProcess.command
				}, { cause: e });
			}
		}
		getLogger().debug("Reusing existing OpenCode process", {
			port,
			processId: existingProcess.id
		});
		return existingProcess;
	}
	try {
		return await startOpencodeServer(sandbox, port, directory, config);
	} catch (startupError) {
		const retryProcess = await findExistingOpencodeProcess(sandbox, port);
		if (retryProcess) {
			getLogger().debug("Startup failed but found concurrent process, reusing", {
				port,
				processId: retryProcess.id
			});
			if (retryProcess.status === "starting") try {
				await retryProcess.waitForPort(port, {
					mode: "http",
					path: "/",
					timeout: 6e4
				});
			} catch (e) {
				const logs = await retryProcess.getLogs();
				throw new OpencodeStartupError(`OpenCode server failed to start. Stderr: ${logs.stderr || "(empty)"}`, {
					port,
					stderr: logs.stderr,
					command: retryProcess.command
				}, { cause: e });
			}
			return retryProcess;
		}
		throw startupError;
	}
}
/**
* Internal function to start a new OpenCode server process.
*/
async function startOpencodeServer(sandbox, port, directory, config) {
	getLogger().info("Starting OpenCode server", {
		port,
		directory
	});
	const env = {};
	if (config) {
		env.OPENCODE_CONFIG_CONTENT = JSON.stringify(config);
		if (config.provider && typeof config.provider === "object" && !Array.isArray(config.provider)) for (const [providerId, providerConfig] of Object.entries(config.provider)) {
			let apiKey = providerConfig?.options?.apiKey;
			if (!apiKey) apiKey = providerConfig?.apiKey;
			if (typeof apiKey === "string") {
				const envVar = `${providerId.toUpperCase()}_API_KEY`;
				env[envVar] = apiKey;
			}
		}
	}
	const command = buildOpencodeCommand(port, directory);
	const process = await sandbox.startProcess(command, { env: Object.keys(env).length > 0 ? env : void 0 });
	try {
		await process.waitForPort(port, {
			mode: "http",
			path: "/",
			timeout: 6e4
		});
		getLogger().info("OpenCode server started successfully", {
			port,
			processId: process.id
		});
	} catch (e) {
		const logs = await process.getLogs();
		const error = e instanceof Error ? e : void 0;
		getLogger().error("OpenCode server failed to start", error, {
			port,
			stderr: logs.stderr
		});
		throw new OpencodeStartupError(`OpenCode server failed to start. Stderr: ${logs.stderr || "(empty)"}`, {
			port,
			stderr: logs.stderr,
			command
		}, { cause: e });
	}
	return process;
}
/**
* Starts an OpenCode server inside a Sandbox container.
*
* This function manages the server lifecycle only - use `createOpencode()` if you
* also need a typed SDK client for programmatic access.
*
* If an OpenCode server is already running on the specified port, this function
* will reuse it instead of starting a new one.
*
* @param sandbox - The Sandbox instance to run OpenCode in
* @param options - Configuration options
* @returns Promise resolving to server handle { port, url, close() }
*
* @example
* ```typescript
* import { getSandbox } from '@cloudflare/sandbox'
* import { createOpencodeServer } from '@cloudflare/sandbox/opencode'
*
* const sandbox = getSandbox(env.Sandbox, 'my-agent')
* const server = await createOpencodeServer(sandbox, {
*   directory: '/home/user/my-project',
*   config: { provider: { anthropic: { options: { apiKey: env.ANTHROPIC_KEY } } } }
* })
*
* // Proxy requests to the web UI
* return sandbox.containerFetch(request, server.port)
*
* // When done
* await server.close()
* ```
*/
async function createOpencodeServer(sandbox, options) {
	const port = options?.port ?? DEFAULT_PORT;
	const process = await ensureOpencodeServer(sandbox, port, options?.directory, options?.config);
	return {
		port,
		url: `http://localhost:${port}`,
		close: () => process.kill("SIGTERM")
	};
}
/**
* Creates an OpenCode server inside a Sandbox container and returns a typed SDK client.
*
* This function is API-compatible with OpenCode's own createOpencode(), but uses
* Sandbox process management instead of Node.js spawn. The returned client uses
* a custom fetch adapter to route requests through the Sandbox container.
*
* If an OpenCode server is already running on the specified port, this function
* will reuse it instead of starting a new one.
*
* @param sandbox - The Sandbox instance to run OpenCode in
* @param options - Configuration options
* @returns Promise resolving to { client, server }
*
* @example
* ```typescript
* import { getSandbox } from '@cloudflare/sandbox'
* import { createOpencode } from '@cloudflare/sandbox/opencode'
*
* const sandbox = getSandbox(env.Sandbox, 'my-agent')
* const { client, server } = await createOpencode(sandbox, {
*   directory: '/home/user/my-project',
*   config: { provider: { anthropic: { options: { apiKey: env.ANTHROPIC_KEY } } } }
* })
*
* // Use the SDK client for programmatic access
* const session = await client.session.create()
*
* // When done
* await server.close()
* ```
*/
async function createOpencode(sandbox, options) {
	await ensureSdkLoaded();
	const server = await createOpencodeServer(sandbox, options);
	return {
		client: createOpencodeClient({
			baseUrl: server.url,
			fetch: (request) => sandbox.containerFetch(request, server.port)
		}),
		server
	};
}
/**
* Proxy a request to the OpenCode web UI.
*
* This function handles the redirect and proxying only - you must start the
* server separately using `createOpencodeServer()`.
*
* Specifically handles:
* 1. Ensuring the `?url=` parameter is set (required for OpenCode's frontend to
*    make API calls through the proxy instead of directly to localhost:4096)
* 2. Proxying the request to the container
*
* @param request - The incoming HTTP request
* @param sandbox - The Sandbox instance running OpenCode
* @param server - The OpenCode server handle from createOpencodeServer()
* @returns Response from OpenCode or a redirect response
*
* @example
* ```typescript
* import { getSandbox } from '@cloudflare/sandbox'
* import { createOpencodeServer, proxyToOpencode } from '@cloudflare/sandbox/opencode'
*
* export default {
*   async fetch(request: Request, env: Env) {
*     const sandbox = getSandbox(env.Sandbox, 'opencode')
*     const server = await createOpencodeServer(sandbox, {
*       directory: '/home/user/project',
*       config: { provider: { anthropic: { options: { apiKey: env.ANTHROPIC_KEY } } } }
*     })
*     return proxyToOpencode(request, sandbox, server)
*   }
* }
* ```
*/
function proxyToOpencode(request, sandbox, server) {
	const url = new URL(request.url);
	if (!url.searchParams.has("url") && request.method === "GET") {
		if ((request.headers.get("accept") || "").includes("text/html") || url.pathname === "/") {
			url.searchParams.set("url", url.origin);
			return Response.redirect(url.toString(), 302);
		}
	}
	return sandbox.containerFetch(request, server.port);
}

//#endregion
export { OpencodeStartupError, createOpencode, createOpencodeServer, proxyToOpencode };
//# sourceMappingURL=index.js.map