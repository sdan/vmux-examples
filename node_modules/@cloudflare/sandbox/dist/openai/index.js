import { l as createLogger } from "../dist-c_xYW5i_.js";
import { applyDiff } from "@openai/agents";

//#region src/openai/index.ts
/**
* OpenAI Agents adapters for executing shell commands and file operations
* inside a Cloudflare Sandbox.
*/
function isErrorWithProperties(error) {
	return typeof error === "object" && error !== null;
}
function getErrorMessage(error) {
	if (isErrorWithProperties(error) && typeof error.message === "string") return error.message;
	return String(error);
}
/**
* Convert unknown values to Error instances when possible so downstream
* loggers can include stack traces without losing type safety.
*/
function toError(error) {
	return error instanceof Error ? error : void 0;
}
/**
* Shell implementation that adapts Cloudflare Sandbox exec calls to the
* OpenAI Agents `Shell` contract, including structured result collection.
*/
var Shell = class {
	cwd = "/workspace";
	results = [];
	logger;
	constructor(sandbox) {
		this.sandbox = sandbox;
		this.logger = createLogger({
			component: "sandbox-do",
			operation: "openai-shell"
		});
	}
	async run(action) {
		this.logger.debug("SandboxShell.run called", {
			commands: action.commands,
			timeout: action.timeoutMs
		});
		const output = [];
		for (const command of action.commands) {
			this.logger.debug("Executing command", {
				command,
				cwd: this.cwd
			});
			let stdout = "";
			let stderr = "";
			let exitCode = 0;
			let outcome = {
				type: "exit",
				exitCode: 0
			};
			try {
				const result = await this.sandbox.exec(command, {
					timeout: action.timeoutMs,
					cwd: this.cwd
				});
				stdout = result.stdout;
				stderr = result.stderr;
				exitCode = result.exitCode;
				outcome = {
					type: "exit",
					exitCode
				};
				this.logger.debug("Command executed successfully", {
					command,
					exitCode,
					stdoutLength: stdout.length,
					stderrLength: stderr.length
				});
				if (exitCode !== 0) this.logger.warn(`Command failed with exit code ${exitCode}`, {
					command,
					stderr
				});
				else if (stderr) this.logger.warn(`Command produced stderr output`, {
					command,
					stderr
				});
				else this.logger.info(`Command completed successfully`, { command });
			} catch (error) {
				const errorObj = isErrorWithProperties(error) ? error : {};
				exitCode = typeof errorObj.exitCode === "number" ? errorObj.exitCode : null;
				stdout = typeof errorObj.stdout === "string" ? errorObj.stdout : "";
				stderr = typeof errorObj.stderr === "string" ? errorObj.stderr : "";
				const errorMessage = getErrorMessage(error);
				if (errorMessage.includes("timeout") || errorMessage.includes("Timeout") || errorMessage.includes("timed out")) {
					this.logger.error(`Command timed out`, void 0, {
						command,
						timeout: action.timeoutMs
					});
					outcome = { type: "timeout" };
				} else {
					this.logger.error(`Error executing command`, toError(error), {
						command,
						error: errorMessage || error,
						exitCode
					});
					outcome = {
						type: "exit",
						exitCode: exitCode ?? 1
					};
				}
			}
			output.push({
				command,
				stdout,
				stderr,
				outcome
			});
			const collectedExitCode = outcome.type === "exit" ? outcome.exitCode : null;
			const timestamp = Date.now();
			this.results.push({
				command: String(command),
				stdout: String(stdout),
				stderr: String(stderr),
				exitCode: collectedExitCode,
				timestamp
			});
			this.logger.debug("Result collected", {
				command,
				exitCode: collectedExitCode,
				timestamp
			});
			if (outcome.type === "timeout") {
				this.logger.warn("Breaking command loop due to timeout");
				break;
			}
		}
		this.logger.debug("SandboxShell.run completed", {
			totalCommands: action.commands.length,
			resultsCount: this.results.length
		});
		return {
			output,
			providerData: { working_directory: this.cwd }
		};
	}
};
/**
* Editor implementation that projects applyPatch operations from Agents
* into calls against the sandbox filesystem APIs.
*/
var Editor = class {
	results = [];
	logger;
	constructor(sandbox, root = "/workspace") {
		this.sandbox = sandbox;
		this.root = root;
		this.logger = createLogger({
			component: "sandbox-do",
			operation: "openai-editor"
		});
	}
	/**
	* Create a new file inside the sandbox by applying the provided diff.
	*/
	async createFile(operation) {
		const targetPath = this.resolve(operation.path);
		this.logger.debug("WorkspaceEditor.createFile called", {
			path: operation.path,
			targetPath
		});
		try {
			const dirPath = this.getDirname(targetPath);
			if (dirPath !== this.root && dirPath !== "/") {
				this.logger.debug("Creating parent directory", { dirPath });
				await this.sandbox.mkdir(dirPath, { recursive: true });
			}
			const content = applyDiff("", operation.diff, "create");
			this.logger.debug("Writing file content", {
				path: targetPath,
				contentLength: content.length
			});
			await this.sandbox.writeFile(targetPath, content, { encoding: "utf-8" });
			const timestamp = Date.now();
			const result = {
				operation: "create",
				path: operation.path,
				status: "completed",
				output: `Created ${operation.path}`,
				timestamp
			};
			this.results.push(result);
			this.logger.info("File created successfully", {
				path: operation.path,
				timestamp
			});
			return {
				status: "completed",
				output: `Created ${operation.path}`
			};
		} catch (error) {
			const timestamp = Date.now();
			const errorMessage = getErrorMessage(error);
			const result = {
				operation: "create",
				path: operation.path,
				status: "failed",
				output: `Failed to create ${operation.path}`,
				error: errorMessage,
				timestamp
			};
			this.results.push(result);
			this.logger.error("Failed to create file", toError(error), {
				path: operation.path,
				error: errorMessage
			});
			throw error;
		}
	}
	/**
	* Update an existing file by reading its content, applying a diff, and
	* writing the patched output back to the sandbox.
	*/
	async updateFile(operation) {
		const targetPath = this.resolve(operation.path);
		this.logger.debug("WorkspaceEditor.updateFile called", {
			path: operation.path,
			targetPath
		});
		try {
			let original;
			try {
				this.logger.debug("Reading original file", { path: targetPath });
				original = (await this.sandbox.readFile(targetPath, { encoding: "utf-8" })).content;
				this.logger.debug("Original file read", {
					path: targetPath,
					originalLength: original.length
				});
			} catch (error) {
				const errorObj = isErrorWithProperties(error) ? error : {};
				const errorMessage = getErrorMessage(error);
				if (errorMessage.includes("not found") || errorMessage.includes("ENOENT") || errorObj.status === 404) {
					this.logger.error("Cannot update missing file", void 0, { path: operation.path });
					throw new Error(`Cannot update missing file: ${operation.path}`);
				}
				this.logger.error("Error reading file", toError(error), {
					path: operation.path,
					error: errorMessage
				});
				throw error;
			}
			const patched = applyDiff(original, operation.diff);
			this.logger.debug("Applied diff", {
				path: targetPath,
				originalLength: original.length,
				patchedLength: patched.length
			});
			await this.sandbox.writeFile(targetPath, patched, { encoding: "utf-8" });
			const timestamp = Date.now();
			const result = {
				operation: "update",
				path: operation.path,
				status: "completed",
				output: `Updated ${operation.path}`,
				timestamp
			};
			this.results.push(result);
			this.logger.info("File updated successfully", {
				path: operation.path,
				timestamp
			});
			return {
				status: "completed",
				output: `Updated ${operation.path}`
			};
		} catch (error) {
			const timestamp = Date.now();
			const errorMessage = getErrorMessage(error);
			const result = {
				operation: "update",
				path: operation.path,
				status: "failed",
				output: `Failed to update ${operation.path}`,
				error: errorMessage,
				timestamp
			};
			this.results.push(result);
			this.logger.error("Failed to update file", toError(error), {
				path: operation.path,
				error: errorMessage
			});
			throw error;
		}
	}
	/**
	* Delete a file that was previously created through applyPatch calls.
	*/
	async deleteFile(operation) {
		const targetPath = this.resolve(operation.path);
		this.logger.debug("WorkspaceEditor.deleteFile called", {
			path: operation.path,
			targetPath
		});
		try {
			await this.sandbox.deleteFile(targetPath);
			const timestamp = Date.now();
			const result = {
				operation: "delete",
				path: operation.path,
				status: "completed",
				output: `Deleted ${operation.path}`,
				timestamp
			};
			this.results.push(result);
			this.logger.info("File deleted successfully", {
				path: operation.path,
				timestamp
			});
			return {
				status: "completed",
				output: `Deleted ${operation.path}`
			};
		} catch (error) {
			const timestamp = Date.now();
			const errorMessage = getErrorMessage(error);
			const result = {
				operation: "delete",
				path: operation.path,
				status: "failed",
				output: `Failed to delete ${operation.path}`,
				error: errorMessage,
				timestamp
			};
			this.results.push(result);
			this.logger.error("Failed to delete file", toError(error), {
				path: operation.path,
				error: errorMessage
			});
			throw error;
		}
	}
	resolve(relativePath) {
		let pathToProcess = relativePath;
		if (relativePath.startsWith(this.root)) {
			pathToProcess = relativePath.slice(this.root.length);
			pathToProcess = pathToProcess.replace(/^\//, "");
		}
		const normalized = pathToProcess.replace(/^\.\//, "").replace(/^\//, "");
		const segments = (normalized ? `${this.root}/${normalized}` : this.root).replace(/\/+/g, "/").split("/").filter((s) => s && s !== ".");
		const stack = [];
		for (const segment of segments) if (segment === "..") {
			if (stack.length === 0) throw new Error(`Operation outside workspace: ${relativePath}`);
			stack.pop();
		} else stack.push(segment);
		const normalizedPath = `/${stack.join("/")}`;
		if (!normalizedPath.startsWith(this.root)) throw new Error(`Operation outside workspace: ${relativePath}`);
		return normalizedPath;
	}
	getDirname(filePath) {
		const lastSlash = filePath.lastIndexOf("/");
		if (lastSlash === -1) return "/";
		return filePath.substring(0, lastSlash) || "/";
	}
};

//#endregion
export { Editor, Shell };
//# sourceMappingURL=index.js.map