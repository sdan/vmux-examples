import { $ as ProcessInfoResult, A as RequestConfig, B as FileChunk, C as WriteFileRequest, D as ContainerStub, E as BaseApiResponse, F as BucketProvider, G as ListFilesOptions, H as FileStreamEvent, I as ExecEvent, J as PortCloseResult, K as LogEvent, L as ExecOptions, M as SessionRequest, N as BaseExecOptions, O as ErrorResponse, P as BucketCredentials, Q as ProcessCleanupResult, R as ExecResult, S as ReadFileRequest, T as ExecuteResponse, U as GitCheckoutResult, V as FileMetadata, W as ISandbox, X as PortListResult, Y as PortExposeResult, Z as Process, _ as GitCheckoutRequest, _t as ExecutionResult, a as CreateSessionRequest, at as ProcessStatus, b as FileOperationRequest, c as DeleteSessionResponse, ct as StreamOptions, d as ProcessClient, dt as isExecResult, et as ProcessKillResult, f as ExposePortRequest, ft as isProcess, g as InterpreterClient, gt as Execution, h as ExecutionCallbacks, ht as CreateContextOptions, i as CommandsResponse, it as ProcessStartResult, j as ResponseHandler, k as HttpClientOptions, l as PingResponse, lt as WaitForLogResult, m as UnexposePortRequest, mt as CodeContext, n as getSandbox, nt as ProcessLogsResult, o as CreateSessionResponse, ot as SandboxOptions, p as PortClient, pt as isProcessStatus, q as MountBucketOptions, r as SandboxClient, rt as ProcessOptions, s as DeleteSessionRequest, st as SessionOptions, t as Sandbox, tt as ProcessListResult, u as UtilityClient, ut as WaitForPortOptions, v as GitClient, vt as RunCodeOptions, w as CommandClient, x as MkdirRequest, y as FileClient, z as ExecutionSession } from "./sandbox-DAb6o08K.js";
import { a as OperationType, i as ErrorResponse$1, n as ProcessExitedBeforeReadyContext, o as ErrorCode, r as ProcessReadyTimeoutContext } from "./contexts-CdrlvHWK.js";

//#region ../shared/dist/request-types.d.ts

/**
 * Request types for API calls to the container
 * Single source of truth for the contract between SDK clients and container handlers
 */
/**
 * Request to execute a command
 */
interface ExecuteRequest {
  command: string;
  sessionId?: string;
  background?: boolean;
  timeoutMs?: number;
  env?: Record<string, string>;
  cwd?: string;
}
/**
 * Request to start a background process
 * Uses flat structure consistent with other endpoints
 */
interface StartProcessRequest {
  command: string;
  sessionId?: string;
  processId?: string;
  timeoutMs?: number;
  env?: Record<string, string>;
  cwd?: string;
  encoding?: string;
  autoCleanup?: boolean;
}
//#endregion
//#region src/errors/classes.d.ts
/**
 * Base SDK error that wraps ErrorResponse
 * Preserves all error information from container
 */
declare class SandboxError<TContext = Record<string, unknown>> extends Error {
  readonly errorResponse: ErrorResponse$1<TContext>;
  constructor(errorResponse: ErrorResponse$1<TContext>);
  get code(): ErrorCode;
  get context(): TContext;
  get httpStatus(): number;
  get operation(): OperationType | undefined;
  get suggestion(): string | undefined;
  get timestamp(): string;
  get documentation(): string | undefined;
  toJSON(): {
    name: string;
    message: string;
    code: ErrorCode;
    context: TContext;
    httpStatus: number;
    operation: OperationType | undefined;
    suggestion: string | undefined;
    timestamp: string;
    documentation: string | undefined;
    stack: string | undefined;
  };
}
/**
 * Error thrown when a process does not become ready within the timeout period
 */
declare class ProcessReadyTimeoutError extends SandboxError<ProcessReadyTimeoutContext> {
  constructor(errorResponse: ErrorResponse$1<ProcessReadyTimeoutContext>);
  get processId(): string;
  get command(): string;
  get condition(): string;
  get timeout(): number;
}
/**
 * Error thrown when a process exits before becoming ready
 */
declare class ProcessExitedBeforeReadyError extends SandboxError<ProcessExitedBeforeReadyContext> {
  constructor(errorResponse: ErrorResponse$1<ProcessExitedBeforeReadyContext>);
  get processId(): string;
  get command(): string;
  get condition(): string;
  get exitCode(): number;
}
//#endregion
//#region src/file-stream.d.ts
/**
 * Stream a file from the sandbox with automatic base64 decoding for binary files
 *
 * @param stream - The ReadableStream from readFileStream()
 * @returns AsyncGenerator that yields FileChunk (string for text, Uint8Array for binary)
 *
 * @example
 * ```ts
 * const stream = await sandbox.readFileStream('/path/to/file.png');
 * for await (const chunk of streamFile(stream)) {
 *   if (chunk instanceof Uint8Array) {
 *     // Binary chunk
 *     console.log('Binary chunk:', chunk.length, 'bytes');
 *   } else {
 *     // Text chunk
 *     console.log('Text chunk:', chunk);
 *   }
 * }
 * ```
 */
declare function streamFile(stream: ReadableStream<Uint8Array>): AsyncGenerator<FileChunk, FileMetadata>;
/**
 * Collect an entire file into memory from a stream
 *
 * @param stream - The ReadableStream from readFileStream()
 * @returns Object containing the file content and metadata
 *
 * @example
 * ```ts
 * const stream = await sandbox.readFileStream('/path/to/file.txt');
 * const { content, metadata } = await collectFile(stream);
 * console.log('Content:', content);
 * console.log('MIME type:', metadata.mimeType);
 * ```
 */
declare function collectFile(stream: ReadableStream<Uint8Array>): Promise<{
  content: string | Uint8Array;
  metadata: FileMetadata;
}>;
//#endregion
//#region src/interpreter.d.ts
declare class CodeInterpreter {
  private interpreterClient;
  private contexts;
  constructor(sandbox: Sandbox);
  /**
   * Create a new code execution context
   */
  createCodeContext(options?: CreateContextOptions): Promise<CodeContext>;
  /**
   * Run code with optional context
   */
  runCode(code: string, options?: RunCodeOptions): Promise<Execution>;
  /**
   * Run code and return a streaming response
   */
  runCodeStream(code: string, options?: RunCodeOptions): Promise<ReadableStream>;
  /**
   * List all code contexts
   */
  listCodeContexts(): Promise<CodeContext[]>;
  /**
   * Delete a code context
   */
  deleteCodeContext(contextId: string): Promise<void>;
  private getOrCreateDefaultContext;
}
//#endregion
//#region src/request-handler.d.ts
interface SandboxEnv<T extends Sandbox<any> = Sandbox<any>> {
  Sandbox: DurableObjectNamespace<T>;
}
interface RouteInfo {
  port: number;
  sandboxId: string;
  path: string;
  token: string;
}
declare function proxyToSandbox<T extends Sandbox<any>, E extends SandboxEnv<T>>(request: Request, env: E): Promise<Response | null>;
//#endregion
//#region src/sse-parser.d.ts
/**
 * Server-Sent Events (SSE) parser for streaming responses
 * Converts ReadableStream<Uint8Array> to typed AsyncIterable<T>
 */
/**
 * Parse a ReadableStream of SSE events into typed AsyncIterable
 * @param stream - The ReadableStream from fetch response
 * @param signal - Optional AbortSignal for cancellation
 */
declare function parseSSEStream<T>(stream: ReadableStream<Uint8Array>, signal?: AbortSignal): AsyncIterable<T>;
/**
 * Helper to convert a Response with SSE stream directly to AsyncIterable
 * @param response - Response object with SSE stream
 * @param signal - Optional AbortSignal for cancellation
 */
declare function responseToAsyncIterable<T>(response: Response, signal?: AbortSignal): AsyncIterable<T>;
/**
 * Create an SSE-formatted ReadableStream from an AsyncIterable
 * (Useful for Worker endpoints that need to forward AsyncIterable as SSE)
 * @param events - AsyncIterable of events
 * @param options - Stream options
 */
declare function asyncIterableToSSEStream<T>(events: AsyncIterable<T>, options?: {
  signal?: AbortSignal;
  serialize?: (event: T) => string;
}): ReadableStream<Uint8Array>;
//#endregion
//#region src/storage-mount/errors.d.ts
/**
 * Base error for bucket mounting operations
 */
declare class BucketMountError extends Error {
  readonly code: ErrorCode;
  constructor(message: string, code?: ErrorCode);
}
/**
 * Thrown when S3FS mount command fails
 */
declare class S3FSMountError extends BucketMountError {
  constructor(message: string);
}
/**
 * Thrown when no credentials found in environment
 */
declare class MissingCredentialsError extends BucketMountError {
  constructor(message: string);
}
/**
 * Thrown when bucket name, mount path, or options are invalid
 */
declare class InvalidMountConfigError extends BucketMountError {
  constructor(message: string);
}
//#endregion
export { type BaseApiResponse, type BaseExecOptions, type BucketCredentials, BucketMountError, type BucketProvider, type CodeContext, CodeInterpreter, CommandClient, type ExecuteResponse as CommandExecuteResponse, type CommandsResponse, type ContainerStub, type CreateContextOptions, type CreateSessionRequest, type CreateSessionResponse, type DeleteSessionRequest, type DeleteSessionResponse, type ErrorResponse, type ExecEvent, type ExecOptions, type ExecResult, type ExecuteRequest, type ExecutionCallbacks, type ExecutionResult, type ExecutionSession, type ExposePortRequest, type FileChunk, FileClient, type FileMetadata, type FileOperationRequest, type FileStreamEvent, type GitCheckoutRequest, type GitCheckoutResult, GitClient, type ISandbox, type InterpreterClient, InvalidMountConfigError, type ListFilesOptions, type LogEvent, MissingCredentialsError, type MkdirRequest, type MountBucketOptions, type PingResponse, PortClient, type PortCloseResult, type PortExposeResult, type PortListResult, type Process, type ProcessCleanupResult, ProcessClient, ProcessExitedBeforeReadyError, type ProcessInfoResult, type ProcessKillResult, type ProcessListResult, type ProcessLogsResult, type ProcessOptions, ProcessReadyTimeoutError, type ProcessStartResult, type ProcessStatus, type ReadFileRequest, type RequestConfig, type ResponseHandler, type RouteInfo, type RunCodeOptions, S3FSMountError, Sandbox, SandboxClient, type HttpClientOptions as SandboxClientOptions, type SandboxEnv, type SandboxOptions, type SessionOptions, type SessionRequest, type StartProcessRequest, type StreamOptions, type UnexposePortRequest, UtilityClient, type WaitForLogResult, type WaitForPortOptions, type WriteFileRequest, asyncIterableToSSEStream, collectFile, getSandbox, isExecResult, isProcess, isProcessStatus, parseSSEStream, proxyToSandbox, responseToAsyncIterable, streamFile };
//# sourceMappingURL=index.d.ts.map