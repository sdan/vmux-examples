import { a as isExecResult, c as shellEscape, d as TraceContext, f as Execution, g as getEnvString, h as extractRepoName, i as isWSStreamChunk, l as createLogger, m as GitLogger, n as isWSError, o as isProcess, p as ResultImpl, r as isWSResponse, s as isProcessStatus, t as generateRequestId, u as createNoOpLogger } from "./dist-c_xYW5i_.js";
import { t as ErrorCode } from "./errors-BCXUmJUn.js";
import { Container, getContainer, switchPort } from "@cloudflare/containers";

//#region src/errors/classes.ts
/**
* Base SDK error that wraps ErrorResponse
* Preserves all error information from container
*/
var SandboxError = class extends Error {
	constructor(errorResponse) {
		super(errorResponse.message);
		this.errorResponse = errorResponse;
		this.name = "SandboxError";
	}
	get code() {
		return this.errorResponse.code;
	}
	get context() {
		return this.errorResponse.context;
	}
	get httpStatus() {
		return this.errorResponse.httpStatus;
	}
	get operation() {
		return this.errorResponse.operation;
	}
	get suggestion() {
		return this.errorResponse.suggestion;
	}
	get timestamp() {
		return this.errorResponse.timestamp;
	}
	get documentation() {
		return this.errorResponse.documentation;
	}
	toJSON() {
		return {
			name: this.name,
			message: this.message,
			code: this.code,
			context: this.context,
			httpStatus: this.httpStatus,
			operation: this.operation,
			suggestion: this.suggestion,
			timestamp: this.timestamp,
			documentation: this.documentation,
			stack: this.stack
		};
	}
};
/**
* Error thrown when a file or directory is not found
*/
var FileNotFoundError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "FileNotFoundError";
	}
	get path() {
		return this.context.path;
	}
};
/**
* Error thrown when a file already exists
*/
var FileExistsError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "FileExistsError";
	}
	get path() {
		return this.context.path;
	}
};
/**
* Generic file system error (permissions, disk full, etc.)
*/
var FileSystemError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "FileSystemError";
	}
	get path() {
		return this.context.path;
	}
	get stderr() {
		return this.context.stderr;
	}
	get exitCode() {
		return this.context.exitCode;
	}
};
/**
* Error thrown when permission is denied
*/
var PermissionDeniedError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "PermissionDeniedError";
	}
	get path() {
		return this.context.path;
	}
};
/**
* Error thrown when a command is not found
*/
var CommandNotFoundError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "CommandNotFoundError";
	}
	get command() {
		return this.context.command;
	}
};
/**
* Generic command execution error
*/
var CommandError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "CommandError";
	}
	get command() {
		return this.context.command;
	}
	get exitCode() {
		return this.context.exitCode;
	}
	get stdout() {
		return this.context.stdout;
	}
	get stderr() {
		return this.context.stderr;
	}
};
/**
* Error thrown when a process is not found
*/
var ProcessNotFoundError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ProcessNotFoundError";
	}
	get processId() {
		return this.context.processId;
	}
};
/**
* Generic process error
*/
var ProcessError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ProcessError";
	}
	get processId() {
		return this.context.processId;
	}
	get pid() {
		return this.context.pid;
	}
	get exitCode() {
		return this.context.exitCode;
	}
	get stderr() {
		return this.context.stderr;
	}
};
/**
* Error thrown when a session already exists
*/
var SessionAlreadyExistsError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "SessionAlreadyExistsError";
	}
	get sessionId() {
		return this.context.sessionId;
	}
};
/**
* Error thrown when a port is already exposed
*/
var PortAlreadyExposedError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "PortAlreadyExposedError";
	}
	get port() {
		return this.context.port;
	}
	get portName() {
		return this.context.portName;
	}
};
/**
* Error thrown when a port is not exposed
*/
var PortNotExposedError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "PortNotExposedError";
	}
	get port() {
		return this.context.port;
	}
};
/**
* Error thrown when a port number is invalid
*/
var InvalidPortError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "InvalidPortError";
	}
	get port() {
		return this.context.port;
	}
	get reason() {
		return this.context.reason;
	}
};
/**
* Error thrown when a service on a port is not responding
*/
var ServiceNotRespondingError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ServiceNotRespondingError";
	}
	get port() {
		return this.context.port;
	}
	get portName() {
		return this.context.portName;
	}
};
/**
* Error thrown when a port is already in use
*/
var PortInUseError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "PortInUseError";
	}
	get port() {
		return this.context.port;
	}
};
/**
* Generic port operation error
*/
var PortError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "PortError";
	}
	get port() {
		return this.context.port;
	}
	get portName() {
		return this.context.portName;
	}
	get stderr() {
		return this.context.stderr;
	}
};
/**
* Error thrown when port exposure requires a custom domain
*/
var CustomDomainRequiredError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "CustomDomainRequiredError";
	}
};
/**
* Error thrown when a git repository is not found
*/
var GitRepositoryNotFoundError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitRepositoryNotFoundError";
	}
	get repository() {
		return this.context.repository;
	}
};
/**
* Error thrown when git authentication fails
*/
var GitAuthenticationError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitAuthenticationError";
	}
	get repository() {
		return this.context.repository;
	}
};
/**
* Error thrown when a git branch is not found
*/
var GitBranchNotFoundError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitBranchNotFoundError";
	}
	get branch() {
		return this.context.branch;
	}
	get repository() {
		return this.context.repository;
	}
};
/**
* Error thrown when a git network operation fails
*/
var GitNetworkError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitNetworkError";
	}
	get repository() {
		return this.context.repository;
	}
	get branch() {
		return this.context.branch;
	}
	get targetDir() {
		return this.context.targetDir;
	}
};
/**
* Error thrown when git clone fails
*/
var GitCloneError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitCloneError";
	}
	get repository() {
		return this.context.repository;
	}
	get targetDir() {
		return this.context.targetDir;
	}
	get stderr() {
		return this.context.stderr;
	}
	get exitCode() {
		return this.context.exitCode;
	}
};
/**
* Error thrown when git checkout fails
*/
var GitCheckoutError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitCheckoutError";
	}
	get branch() {
		return this.context.branch;
	}
	get repository() {
		return this.context.repository;
	}
	get stderr() {
		return this.context.stderr;
	}
};
/**
* Error thrown when a git URL is invalid
*/
var InvalidGitUrlError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "InvalidGitUrlError";
	}
	get validationErrors() {
		return this.context.validationErrors;
	}
};
/**
* Generic git operation error
*/
var GitError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "GitError";
	}
	get repository() {
		return this.context.repository;
	}
	get branch() {
		return this.context.branch;
	}
	get targetDir() {
		return this.context.targetDir;
	}
	get stderr() {
		return this.context.stderr;
	}
	get exitCode() {
		return this.context.exitCode;
	}
};
/**
* Error thrown when interpreter is not ready
*/
var InterpreterNotReadyError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "InterpreterNotReadyError";
	}
	get retryAfter() {
		return this.context.retryAfter;
	}
	get progress() {
		return this.context.progress;
	}
};
/**
* Error thrown when a context is not found
*/
var ContextNotFoundError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ContextNotFoundError";
	}
	get contextId() {
		return this.context.contextId;
	}
};
/**
* Error thrown when code execution fails
*/
var CodeExecutionError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "CodeExecutionError";
	}
	get contextId() {
		return this.context.contextId;
	}
	get ename() {
		return this.context.ename;
	}
	get evalue() {
		return this.context.evalue;
	}
	get traceback() {
		return this.context.traceback;
	}
};
/**
* Error thrown when validation fails
*/
var ValidationFailedError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ValidationFailedError";
	}
	get validationErrors() {
		return this.context.validationErrors;
	}
};
/**
* Error thrown when a process does not become ready within the timeout period
*/
var ProcessReadyTimeoutError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ProcessReadyTimeoutError";
	}
	get processId() {
		return this.context.processId;
	}
	get command() {
		return this.context.command;
	}
	get condition() {
		return this.context.condition;
	}
	get timeout() {
		return this.context.timeout;
	}
};
/**
* Error thrown when a process exits before becoming ready
*/
var ProcessExitedBeforeReadyError = class extends SandboxError {
	constructor(errorResponse) {
		super(errorResponse);
		this.name = "ProcessExitedBeforeReadyError";
	}
	get processId() {
		return this.context.processId;
	}
	get command() {
		return this.context.command;
	}
	get condition() {
		return this.context.condition;
	}
	get exitCode() {
		return this.context.exitCode;
	}
};

//#endregion
//#region src/errors/adapter.ts
/**
* Convert ErrorResponse to appropriate Error class
* Simple switch statement - we trust the container sends correct context
*/
function createErrorFromResponse(errorResponse) {
	switch (errorResponse.code) {
		case ErrorCode.FILE_NOT_FOUND: return new FileNotFoundError(errorResponse);
		case ErrorCode.FILE_EXISTS: return new FileExistsError(errorResponse);
		case ErrorCode.PERMISSION_DENIED: return new PermissionDeniedError(errorResponse);
		case ErrorCode.IS_DIRECTORY:
		case ErrorCode.NOT_DIRECTORY:
		case ErrorCode.NO_SPACE:
		case ErrorCode.TOO_MANY_FILES:
		case ErrorCode.RESOURCE_BUSY:
		case ErrorCode.READ_ONLY:
		case ErrorCode.NAME_TOO_LONG:
		case ErrorCode.TOO_MANY_LINKS:
		case ErrorCode.FILESYSTEM_ERROR: return new FileSystemError(errorResponse);
		case ErrorCode.COMMAND_NOT_FOUND: return new CommandNotFoundError(errorResponse);
		case ErrorCode.COMMAND_PERMISSION_DENIED:
		case ErrorCode.COMMAND_EXECUTION_ERROR:
		case ErrorCode.INVALID_COMMAND:
		case ErrorCode.STREAM_START_ERROR: return new CommandError(errorResponse);
		case ErrorCode.PROCESS_NOT_FOUND: return new ProcessNotFoundError(errorResponse);
		case ErrorCode.PROCESS_PERMISSION_DENIED:
		case ErrorCode.PROCESS_ERROR: return new ProcessError(errorResponse);
		case ErrorCode.SESSION_ALREADY_EXISTS: return new SessionAlreadyExistsError(errorResponse);
		case ErrorCode.PORT_ALREADY_EXPOSED: return new PortAlreadyExposedError(errorResponse);
		case ErrorCode.PORT_NOT_EXPOSED: return new PortNotExposedError(errorResponse);
		case ErrorCode.INVALID_PORT_NUMBER:
		case ErrorCode.INVALID_PORT: return new InvalidPortError(errorResponse);
		case ErrorCode.SERVICE_NOT_RESPONDING: return new ServiceNotRespondingError(errorResponse);
		case ErrorCode.PORT_IN_USE: return new PortInUseError(errorResponse);
		case ErrorCode.PORT_OPERATION_ERROR: return new PortError(errorResponse);
		case ErrorCode.CUSTOM_DOMAIN_REQUIRED: return new CustomDomainRequiredError(errorResponse);
		case ErrorCode.GIT_REPOSITORY_NOT_FOUND: return new GitRepositoryNotFoundError(errorResponse);
		case ErrorCode.GIT_AUTH_FAILED: return new GitAuthenticationError(errorResponse);
		case ErrorCode.GIT_BRANCH_NOT_FOUND: return new GitBranchNotFoundError(errorResponse);
		case ErrorCode.GIT_NETWORK_ERROR: return new GitNetworkError(errorResponse);
		case ErrorCode.GIT_CLONE_FAILED: return new GitCloneError(errorResponse);
		case ErrorCode.GIT_CHECKOUT_FAILED: return new GitCheckoutError(errorResponse);
		case ErrorCode.INVALID_GIT_URL: return new InvalidGitUrlError(errorResponse);
		case ErrorCode.GIT_OPERATION_FAILED: return new GitError(errorResponse);
		case ErrorCode.INTERPRETER_NOT_READY: return new InterpreterNotReadyError(errorResponse);
		case ErrorCode.CONTEXT_NOT_FOUND: return new ContextNotFoundError(errorResponse);
		case ErrorCode.CODE_EXECUTION_ERROR: return new CodeExecutionError(errorResponse);
		case ErrorCode.VALIDATION_FAILED: return new ValidationFailedError(errorResponse);
		case ErrorCode.INVALID_JSON_RESPONSE:
		case ErrorCode.UNKNOWN_ERROR:
		case ErrorCode.INTERNAL_ERROR: return new SandboxError(errorResponse);
		default: return new SandboxError(errorResponse);
	}
}

//#endregion
//#region src/clients/transport/base-transport.ts
/**
* Container startup retry configuration
*/
const TIMEOUT_MS = 12e4;
const MIN_TIME_FOR_RETRY_MS = 15e3;
/**
* Abstract base transport with shared retry logic
*
* Handles 503 retry for container startup - shared by all transports.
* Subclasses implement the transport-specific fetch and stream logic.
*/
var BaseTransport = class {
	config;
	logger;
	constructor(config) {
		this.config = config;
		this.logger = config.logger ?? createNoOpLogger();
	}
	/**
	* Fetch with automatic retry for 503 (container starting)
	*
	* This is the primary entry point for making requests. It wraps the
	* transport-specific doFetch() with retry logic for container startup.
	*/
	async fetch(path, options) {
		const startTime = Date.now();
		let attempt = 0;
		while (true) {
			const response = await this.doFetch(path, options);
			if (response.status === 503) {
				const elapsed = Date.now() - startTime;
				const remaining = TIMEOUT_MS - elapsed;
				if (remaining > MIN_TIME_FOR_RETRY_MS) {
					const delay = Math.min(3e3 * 2 ** attempt, 3e4);
					this.logger.info("Container not ready, retrying", {
						status: response.status,
						attempt: attempt + 1,
						delayMs: delay,
						remainingSec: Math.floor(remaining / 1e3),
						mode: this.getMode()
					});
					await this.sleep(delay);
					attempt++;
					continue;
				}
				this.logger.error("Container failed to become ready", /* @__PURE__ */ new Error(`Failed after ${attempt + 1} attempts over ${Math.floor(elapsed / 1e3)}s`));
			}
			return response;
		}
	}
	/**
	* Sleep utility for retry delays
	*/
	sleep(ms) {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
};

//#endregion
//#region src/clients/transport/http-transport.ts
/**
* HTTP transport implementation
*
* Uses standard fetch API for communication with the container.
* HTTP is stateless, so connect/disconnect are no-ops.
*/
var HttpTransport = class extends BaseTransport {
	baseUrl;
	constructor(config) {
		super(config);
		this.baseUrl = config.baseUrl ?? "http://localhost:3000";
	}
	getMode() {
		return "http";
	}
	async connect() {}
	disconnect() {}
	isConnected() {
		return true;
	}
	async doFetch(path, options) {
		const url = this.buildUrl(path);
		if (this.config.stub) return this.config.stub.containerFetch(url, options || {}, this.config.port);
		return globalThis.fetch(url, options);
	}
	async fetchStream(path, body, method = "POST") {
		const url = this.buildUrl(path);
		const options = this.buildStreamOptions(body, method);
		let response;
		if (this.config.stub) response = await this.config.stub.containerFetch(url, options, this.config.port);
		else response = await globalThis.fetch(url, options);
		if (!response.ok) {
			const errorBody = await response.text();
			throw new Error(`HTTP error! status: ${response.status} - ${errorBody}`);
		}
		if (!response.body) throw new Error("No response body for streaming");
		return response.body;
	}
	buildUrl(path) {
		if (this.config.stub) return `http://localhost:${this.config.port}${path}`;
		return `${this.baseUrl}${path}`;
	}
	buildStreamOptions(body, method) {
		return {
			method,
			headers: body && method === "POST" ? { "Content-Type": "application/json" } : void 0,
			body: body && method === "POST" ? JSON.stringify(body) : void 0
		};
	}
};

//#endregion
//#region src/clients/transport/ws-transport.ts
/**
* WebSocket transport implementation
*
* Multiplexes HTTP-like requests over a single WebSocket connection.
* Useful when running inside Workers/DO where sub-request limits apply.
*/
var WebSocketTransport = class extends BaseTransport {
	ws = null;
	state = "disconnected";
	pendingRequests = /* @__PURE__ */ new Map();
	connectPromise = null;
	boundHandleMessage;
	boundHandleClose;
	constructor(config) {
		super(config);
		if (!config.wsUrl) throw new Error("wsUrl is required for WebSocket transport");
		this.boundHandleMessage = this.handleMessage.bind(this);
		this.boundHandleClose = this.handleClose.bind(this);
	}
	getMode() {
		return "websocket";
	}
	/**
	* Check if WebSocket is connected
	*/
	isConnected() {
		return this.state === "connected" && this.ws?.readyState === WebSocket.OPEN;
	}
	/**
	* Connect to the WebSocket server
	*
	* The connection promise is assigned synchronously so concurrent
	* callers share the same connection attempt.
	*/
	async connect() {
		if (this.isConnected()) return;
		if (this.connectPromise) return this.connectPromise;
		this.connectPromise = this.doConnect();
		try {
			await this.connectPromise;
		} catch (error) {
			this.connectPromise = null;
			throw error;
		}
	}
	/**
	* Disconnect from the WebSocket server
	*/
	disconnect() {
		this.cleanup();
	}
	/**
	* Transport-specific fetch implementation
	* Converts WebSocket response to standard Response object.
	*/
	async doFetch(path, options) {
		await this.connect();
		const method = options?.method || "GET";
		const body = this.parseBody(options?.body);
		const result = await this.request(method, path, body);
		return new Response(JSON.stringify(result.body), {
			status: result.status,
			headers: { "Content-Type": "application/json" }
		});
	}
	/**
	* Streaming fetch implementation
	*/
	async fetchStream(path, body, method = "POST") {
		return this.requestStream(method, path, body);
	}
	/**
	* Parse request body from RequestInit
	*/
	parseBody(body) {
		if (!body) return;
		if (typeof body === "string") try {
			return JSON.parse(body);
		} catch (error) {
			throw new Error(`Request body must be valid JSON: ${error instanceof Error ? error.message : String(error)}`);
		}
		throw new Error(`WebSocket transport only supports string bodies. Got: ${typeof body}`);
	}
	/**
	* Internal connection logic
	*/
	async doConnect() {
		this.state = "connecting";
		if (this.config.stub) await this.connectViaFetch();
		else await this.connectViaWebSocket();
	}
	/**
	* Connect using fetch-based WebSocket (Cloudflare Workers style)
	* This is required when running inside a Durable Object.
	*
	* Uses stub.fetch() which routes WebSocket upgrade requests through the
	* parent Container class that supports the WebSocket protocol.
	*/
	async connectViaFetch() {
		const timeoutMs = this.config.connectTimeoutMs ?? 3e4;
		const controller = new AbortController();
		const timeout = setTimeout(() => controller.abort(), timeoutMs);
		try {
			const wsPath = new URL(this.config.wsUrl).pathname;
			const httpUrl = `http://localhost:${this.config.port || 3e3}${wsPath}`;
			const request = new Request(httpUrl, {
				headers: {
					Upgrade: "websocket",
					Connection: "Upgrade"
				},
				signal: controller.signal
			});
			const response = await this.config.stub.fetch(request);
			clearTimeout(timeout);
			if (response.status !== 101) throw new Error(`WebSocket upgrade failed: ${response.status} ${response.statusText}`);
			const ws = response.webSocket;
			if (!ws) throw new Error("No WebSocket in upgrade response");
			ws.accept();
			this.ws = ws;
			this.state = "connected";
			this.ws.addEventListener("close", this.boundHandleClose);
			this.ws.addEventListener("message", this.boundHandleMessage);
			this.logger.debug("WebSocket connected via fetch", { url: this.config.wsUrl });
		} catch (error) {
			clearTimeout(timeout);
			this.state = "error";
			this.logger.error("WebSocket fetch connection failed", error instanceof Error ? error : new Error(String(error)));
			throw error;
		}
	}
	/**
	* Connect using standard WebSocket API (browser/Node style)
	*/
	connectViaWebSocket() {
		return new Promise((resolve, reject) => {
			const timeoutMs = this.config.connectTimeoutMs ?? 3e4;
			const timeout = setTimeout(() => {
				this.cleanup();
				reject(/* @__PURE__ */ new Error(`WebSocket connection timeout after ${timeoutMs}ms`));
			}, timeoutMs);
			try {
				this.ws = new WebSocket(this.config.wsUrl);
				const onOpen = () => {
					clearTimeout(timeout);
					this.ws?.removeEventListener("open", onOpen);
					this.ws?.removeEventListener("error", onConnectError);
					this.state = "connected";
					this.logger.debug("WebSocket connected", { url: this.config.wsUrl });
					resolve();
				};
				const onConnectError = () => {
					clearTimeout(timeout);
					this.ws?.removeEventListener("open", onOpen);
					this.ws?.removeEventListener("error", onConnectError);
					this.state = "error";
					this.logger.error("WebSocket error", /* @__PURE__ */ new Error("WebSocket connection failed"));
					reject(/* @__PURE__ */ new Error("WebSocket connection failed"));
				};
				this.ws.addEventListener("open", onOpen);
				this.ws.addEventListener("error", onConnectError);
				this.ws.addEventListener("close", this.boundHandleClose);
				this.ws.addEventListener("message", this.boundHandleMessage);
			} catch (error) {
				clearTimeout(timeout);
				this.state = "error";
				reject(error);
			}
		});
	}
	/**
	* Send a request and wait for response
	*/
	async request(method, path, body) {
		await this.connect();
		const id = generateRequestId();
		const request = {
			type: "request",
			id,
			method,
			path,
			body
		};
		return new Promise((resolve, reject) => {
			const timeoutMs = this.config.requestTimeoutMs ?? 12e4;
			const timeoutId = setTimeout(() => {
				this.pendingRequests.delete(id);
				reject(/* @__PURE__ */ new Error(`Request timeout after ${timeoutMs}ms: ${method} ${path}`));
			}, timeoutMs);
			this.pendingRequests.set(id, {
				resolve: (response) => {
					clearTimeout(timeoutId);
					this.pendingRequests.delete(id);
					resolve({
						status: response.status,
						body: response.body
					});
				},
				reject: (error) => {
					clearTimeout(timeoutId);
					this.pendingRequests.delete(id);
					reject(error);
				},
				isStreaming: false,
				timeoutId
			});
			try {
				this.send(request);
			} catch (error) {
				clearTimeout(timeoutId);
				this.pendingRequests.delete(id);
				reject(error instanceof Error ? error : new Error(String(error)));
			}
		});
	}
	/**
	* Send a streaming request and return a ReadableStream
	*
	* The stream will receive data chunks as they arrive over the WebSocket.
	* Format matches SSE for compatibility with existing streaming code.
	*/
	async requestStream(method, path, body) {
		await this.connect();
		const id = generateRequestId();
		const request = {
			type: "request",
			id,
			method,
			path,
			body
		};
		return new ReadableStream({
			start: (controller) => {
				const timeoutMs = this.config.requestTimeoutMs ?? 12e4;
				const timeoutId = setTimeout(() => {
					this.pendingRequests.delete(id);
					controller.error(/* @__PURE__ */ new Error(`Stream timeout after ${timeoutMs}ms: ${method} ${path}`));
				}, timeoutMs);
				this.pendingRequests.set(id, {
					resolve: (response) => {
						clearTimeout(timeoutId);
						this.pendingRequests.delete(id);
						if (response.status >= 400) controller.error(/* @__PURE__ */ new Error(`Stream error: ${response.status} - ${JSON.stringify(response.body)}`));
						else controller.close();
					},
					reject: (error) => {
						clearTimeout(timeoutId);
						this.pendingRequests.delete(id);
						controller.error(error);
					},
					streamController: controller,
					isStreaming: true,
					timeoutId
				});
				try {
					this.send(request);
				} catch (error) {
					clearTimeout(timeoutId);
					this.pendingRequests.delete(id);
					controller.error(error instanceof Error ? error : new Error(String(error)));
				}
			},
			cancel: () => {
				const pending = this.pendingRequests.get(id);
				if (pending?.timeoutId) clearTimeout(pending.timeoutId);
				this.pendingRequests.delete(id);
			}
		});
	}
	/**
	* Send a message over the WebSocket
	*/
	send(message) {
		if (!this.ws || this.ws.readyState !== WebSocket.OPEN) throw new Error("WebSocket not connected");
		this.ws.send(JSON.stringify(message));
		this.logger.debug("WebSocket sent", {
			id: message.id,
			method: message.method,
			path: message.path
		});
	}
	/**
	* Handle incoming WebSocket messages
	*/
	handleMessage(event) {
		try {
			const message = JSON.parse(event.data);
			if (isWSResponse(message)) this.handleResponse(message);
			else if (isWSStreamChunk(message)) this.handleStreamChunk(message);
			else if (isWSError(message)) this.handleError(message);
			else this.logger.warn("Unknown WebSocket message type", { message });
		} catch (error) {
			this.logger.error("Failed to parse WebSocket message", error instanceof Error ? error : new Error(String(error)));
		}
	}
	/**
	* Handle a response message
	*/
	handleResponse(response) {
		const pending = this.pendingRequests.get(response.id);
		if (!pending) {
			this.logger.warn("Received response for unknown request", { id: response.id });
			return;
		}
		this.logger.debug("WebSocket response", {
			id: response.id,
			status: response.status,
			done: response.done
		});
		if (response.done) pending.resolve(response);
	}
	/**
	* Handle a stream chunk message
	*/
	handleStreamChunk(chunk) {
		const pending = this.pendingRequests.get(chunk.id);
		if (!pending || !pending.streamController) {
			this.logger.warn("Received stream chunk for unknown request", { id: chunk.id });
			return;
		}
		const encoder = new TextEncoder();
		let sseData;
		if (chunk.event) sseData = `event: ${chunk.event}\ndata: ${chunk.data}\n\n`;
		else sseData = `data: ${chunk.data}\n\n`;
		try {
			pending.streamController.enqueue(encoder.encode(sseData));
		} catch (error) {
			this.logger.debug("Failed to enqueue stream chunk, cleaning up", {
				id: chunk.id,
				error: error instanceof Error ? error.message : String(error)
			});
			if (pending.timeoutId) clearTimeout(pending.timeoutId);
			this.pendingRequests.delete(chunk.id);
		}
	}
	/**
	* Handle an error message
	*/
	handleError(error) {
		if (error.id) {
			const pending = this.pendingRequests.get(error.id);
			if (pending) {
				pending.reject(/* @__PURE__ */ new Error(`${error.code}: ${error.message}`));
				return;
			}
		}
		this.logger.error("WebSocket error message", new Error(error.message), {
			code: error.code,
			status: error.status
		});
	}
	/**
	* Handle WebSocket close
	*/
	handleClose(event) {
		this.state = "disconnected";
		this.ws = null;
		const closeError = /* @__PURE__ */ new Error(`WebSocket closed: ${event.code} ${event.reason || "No reason"}`);
		for (const [, pending] of this.pendingRequests) {
			if (pending.timeoutId) clearTimeout(pending.timeoutId);
			if (pending.streamController) try {
				pending.streamController.error(closeError);
			} catch {}
			pending.reject(closeError);
		}
		this.pendingRequests.clear();
	}
	/**
	* Cleanup resources
	*/
	cleanup() {
		if (this.ws) {
			this.ws.removeEventListener("close", this.boundHandleClose);
			this.ws.removeEventListener("message", this.boundHandleMessage);
			this.ws.close();
			this.ws = null;
		}
		this.state = "disconnected";
		this.connectPromise = null;
		for (const pending of this.pendingRequests.values()) if (pending.timeoutId) clearTimeout(pending.timeoutId);
		this.pendingRequests.clear();
	}
};

//#endregion
//#region src/clients/transport/factory.ts
/**
* Create a transport instance based on mode
*
* This is the primary API for creating transports. It handles
* the selection of HTTP or WebSocket transport based on the mode.
*
* @example
* ```typescript
* // HTTP transport (default)
* const http = createTransport({
*   mode: 'http',
*   baseUrl: 'http://localhost:3000'
* });
*
* // WebSocket transport
* const ws = createTransport({
*   mode: 'websocket',
*   wsUrl: 'ws://localhost:3000/ws'
* });
* ```
*/
function createTransport(options) {
	switch (options.mode) {
		case "websocket": return new WebSocketTransport(options);
		default: return new HttpTransport(options);
	}
}

//#endregion
//#region src/clients/base-client.ts
/**
* Abstract base class providing common HTTP/WebSocket functionality for all domain clients
*
* All requests go through the Transport abstraction layer, which handles:
* - HTTP and WebSocket modes transparently
* - Automatic retry for 503 errors (container starting)
* - Streaming responses
*
* WebSocket mode is useful when running inside Workers/Durable Objects
* where sub-request limits apply.
*/
var BaseHttpClient = class {
	options;
	logger;
	transport;
	constructor(options = {}) {
		this.options = options;
		this.logger = options.logger ?? createNoOpLogger();
		if (options.transport) this.transport = options.transport;
		else this.transport = createTransport({
			mode: options.transportMode ?? "http",
			baseUrl: options.baseUrl ?? "http://localhost:3000",
			wsUrl: options.wsUrl,
			logger: this.logger,
			stub: options.stub,
			port: options.port
		});
	}
	/**
	* Check if using WebSocket transport
	*/
	isWebSocketMode() {
		return this.transport.getMode() === "websocket";
	}
	/**
	* Core fetch method - delegates to Transport which handles retry logic
	*/
	async doFetch(path, options) {
		return this.transport.fetch(path, options);
	}
	/**
	* Make a POST request with JSON body
	*/
	async post(endpoint, data, responseHandler) {
		const response = await this.doFetch(endpoint, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(data)
		});
		return this.handleResponse(response, responseHandler);
	}
	/**
	* Make a GET request
	*/
	async get(endpoint, responseHandler) {
		const response = await this.doFetch(endpoint, { method: "GET" });
		return this.handleResponse(response, responseHandler);
	}
	/**
	* Make a DELETE request
	*/
	async delete(endpoint, responseHandler) {
		const response = await this.doFetch(endpoint, { method: "DELETE" });
		return this.handleResponse(response, responseHandler);
	}
	/**
	* Handle HTTP response with error checking and parsing
	*/
	async handleResponse(response, customHandler) {
		if (!response.ok) await this.handleErrorResponse(response);
		if (customHandler) return customHandler(response);
		try {
			return await response.json();
		} catch (error) {
			throw createErrorFromResponse({
				code: ErrorCode.INVALID_JSON_RESPONSE,
				message: `Invalid JSON response: ${error instanceof Error ? error.message : "Unknown parsing error"}`,
				context: {},
				httpStatus: response.status,
				timestamp: (/* @__PURE__ */ new Date()).toISOString()
			});
		}
	}
	/**
	* Handle error responses with consistent error throwing
	*/
	async handleErrorResponse(response) {
		let errorData;
		try {
			errorData = await response.json();
		} catch {
			errorData = {
				code: ErrorCode.INTERNAL_ERROR,
				message: `HTTP error! status: ${response.status}`,
				context: { statusText: response.statusText },
				httpStatus: response.status,
				timestamp: (/* @__PURE__ */ new Date()).toISOString()
			};
		}
		const error = createErrorFromResponse(errorData);
		this.options.onError?.(errorData.message, void 0);
		throw error;
	}
	/**
	* Create a streaming response handler for Server-Sent Events
	*/
	async handleStreamResponse(response) {
		if (!response.ok) await this.handleErrorResponse(response);
		if (!response.body) throw new Error("No response body for streaming");
		return response.body;
	}
	/**
	* Stream request handler
	*
	* For HTTP mode, uses doFetch + handleStreamResponse to get proper error typing.
	* For WebSocket mode, uses Transport's streaming support.
	*
	* @param path - The API path to call
	* @param body - Optional request body (for POST requests)
	* @param method - HTTP method (default: POST, use GET for process logs)
	*/
	async doStreamFetch(path, body, method = "POST") {
		if (this.transport.getMode() === "websocket") try {
			return await this.transport.fetchStream(path, body, method);
		} catch (error) {
			this.logError(`stream ${method} ${path}`, error);
			throw error;
		}
		const response = await this.doFetch(path, {
			method,
			headers: { "Content-Type": "application/json" },
			body: body && method === "POST" ? JSON.stringify(body) : void 0
		});
		return this.handleStreamResponse(response);
	}
	/**
	* Utility method to log successful operations
	*/
	logSuccess(operation, details) {
		this.logger.info(operation, details ? { details } : void 0);
	}
	/**
	* Utility method to log errors intelligently
	* Only logs unexpected errors (5xx), not expected errors (4xx)
	*
	* - 4xx errors (validation, not found, conflicts): Don't log (expected client errors)
	* - 5xx errors (server failures, internal errors): DO log (unexpected server errors)
	*/
	logError(operation, error) {
		if (error && typeof error === "object" && "httpStatus" in error) {
			const httpStatus = error.httpStatus;
			if (httpStatus >= 500) this.logger.error(`Unexpected error in ${operation}`, error instanceof Error ? error : new Error(String(error)), { httpStatus });
		} else this.logger.error(`Error in ${operation}`, error instanceof Error ? error : new Error(String(error)));
	}
};

//#endregion
//#region src/clients/command-client.ts
/**
* Client for command execution operations
*/
var CommandClient = class extends BaseHttpClient {
	/**
	* Execute a command and return the complete result
	* @param command - The command to execute
	* @param sessionId - The session ID for this command execution
	* @param timeoutMs - Optional timeout in milliseconds (unlimited by default)
	* @param env - Optional environment variables for this command
	* @param cwd - Optional working directory for this command
	*/
	async execute(command, sessionId, options) {
		try {
			const data = {
				command,
				sessionId,
				...options?.timeoutMs !== void 0 && { timeoutMs: options.timeoutMs },
				...options?.env !== void 0 && { env: options.env },
				...options?.cwd !== void 0 && { cwd: options.cwd }
			};
			const response = await this.post("/api/execute", data);
			this.logSuccess("Command executed", `${command}, Success: ${response.success}`);
			this.options.onCommandComplete?.(response.success, response.exitCode, response.stdout, response.stderr, response.command);
			return response;
		} catch (error) {
			this.logError("execute", error);
			this.options.onError?.(error instanceof Error ? error.message : String(error), command);
			throw error;
		}
	}
	/**
	* Execute a command and return a stream of events
	* @param command - The command to execute
	* @param sessionId - The session ID for this command execution
	* @param options - Optional per-command execution settings
	*/
	async executeStream(command, sessionId, options) {
		try {
			const data = {
				command,
				sessionId,
				...options?.timeoutMs !== void 0 && { timeoutMs: options.timeoutMs },
				...options?.env !== void 0 && { env: options.env },
				...options?.cwd !== void 0 && { cwd: options.cwd }
			};
			const stream = await this.doStreamFetch("/api/execute/stream", data);
			this.logSuccess("Command stream started", command);
			return stream;
		} catch (error) {
			this.logError("executeStream", error);
			this.options.onError?.(error instanceof Error ? error.message : String(error), command);
			throw error;
		}
	}
};

//#endregion
//#region src/clients/file-client.ts
/**
* Client for file system operations
*/
var FileClient = class extends BaseHttpClient {
	/**
	* Create a directory
	* @param path - Directory path to create
	* @param sessionId - The session ID for this operation
	* @param options - Optional settings (recursive)
	*/
	async mkdir(path, sessionId, options) {
		try {
			const data = {
				path,
				sessionId,
				recursive: options?.recursive ?? false
			};
			const response = await this.post("/api/mkdir", data);
			this.logSuccess("Directory created", `${path} (recursive: ${data.recursive})`);
			return response;
		} catch (error) {
			this.logError("mkdir", error);
			throw error;
		}
	}
	/**
	* Write content to a file
	* @param path - File path to write to
	* @param content - Content to write
	* @param sessionId - The session ID for this operation
	* @param options - Optional settings (encoding)
	*/
	async writeFile(path, content, sessionId, options) {
		try {
			const data = {
				path,
				content,
				sessionId,
				encoding: options?.encoding
			};
			const response = await this.post("/api/write", data);
			this.logSuccess("File written", `${path} (${content.length} chars)`);
			return response;
		} catch (error) {
			this.logError("writeFile", error);
			throw error;
		}
	}
	/**
	* Read content from a file
	* @param path - File path to read from
	* @param sessionId - The session ID for this operation
	* @param options - Optional settings (encoding)
	*/
	async readFile(path, sessionId, options) {
		try {
			const data = {
				path,
				sessionId,
				encoding: options?.encoding
			};
			const response = await this.post("/api/read", data);
			this.logSuccess("File read", `${path} (${response.content.length} chars)`);
			return response;
		} catch (error) {
			this.logError("readFile", error);
			throw error;
		}
	}
	/**
	* Stream a file using Server-Sent Events
	* Returns a ReadableStream of SSE events containing metadata, chunks, and completion
	* @param path - File path to stream
	* @param sessionId - The session ID for this operation
	*/
	async readFileStream(path, sessionId) {
		try {
			const data = {
				path,
				sessionId
			};
			const stream = await this.doStreamFetch("/api/read/stream", data);
			this.logSuccess("File stream started", path);
			return stream;
		} catch (error) {
			this.logError("readFileStream", error);
			throw error;
		}
	}
	/**
	* Delete a file
	* @param path - File path to delete
	* @param sessionId - The session ID for this operation
	*/
	async deleteFile(path, sessionId) {
		try {
			const data = {
				path,
				sessionId
			};
			const response = await this.post("/api/delete", data);
			this.logSuccess("File deleted", path);
			return response;
		} catch (error) {
			this.logError("deleteFile", error);
			throw error;
		}
	}
	/**
	* Rename a file
	* @param path - Current file path
	* @param newPath - New file path
	* @param sessionId - The session ID for this operation
	*/
	async renameFile(path, newPath, sessionId) {
		try {
			const data = {
				oldPath: path,
				newPath,
				sessionId
			};
			const response = await this.post("/api/rename", data);
			this.logSuccess("File renamed", `${path} -> ${newPath}`);
			return response;
		} catch (error) {
			this.logError("renameFile", error);
			throw error;
		}
	}
	/**
	* Move a file
	* @param path - Current file path
	* @param newPath - Destination file path
	* @param sessionId - The session ID for this operation
	*/
	async moveFile(path, newPath, sessionId) {
		try {
			const data = {
				sourcePath: path,
				destinationPath: newPath,
				sessionId
			};
			const response = await this.post("/api/move", data);
			this.logSuccess("File moved", `${path} -> ${newPath}`);
			return response;
		} catch (error) {
			this.logError("moveFile", error);
			throw error;
		}
	}
	/**
	* List files in a directory
	* @param path - Directory path to list
	* @param sessionId - The session ID for this operation
	* @param options - Optional settings (recursive, includeHidden)
	*/
	async listFiles(path, sessionId, options) {
		try {
			const data = {
				path,
				sessionId,
				options: options || {}
			};
			const response = await this.post("/api/list-files", data);
			this.logSuccess("Files listed", `${path} (${response.count} files)`);
			return response;
		} catch (error) {
			this.logError("listFiles", error);
			throw error;
		}
	}
	/**
	* Check if a file or directory exists
	* @param path - Path to check
	* @param sessionId - The session ID for this operation
	*/
	async exists(path, sessionId) {
		try {
			const data = {
				path,
				sessionId
			};
			const response = await this.post("/api/exists", data);
			this.logSuccess("Path existence checked", `${path} (exists: ${response.exists})`);
			return response;
		} catch (error) {
			this.logError("exists", error);
			throw error;
		}
	}
};

//#endregion
//#region src/clients/git-client.ts
/**
* Client for Git repository operations
*/
var GitClient = class extends BaseHttpClient {
	constructor(options = {}) {
		super(options);
		this.logger = new GitLogger(this.logger);
	}
	/**
	* Clone a Git repository
	* @param repoUrl - URL of the Git repository to clone
	* @param sessionId - The session ID for this operation
	* @param options - Optional settings (branch, targetDir, depth)
	*/
	async checkout(repoUrl, sessionId, options) {
		try {
			let targetDir = options?.targetDir;
			if (!targetDir) targetDir = `/workspace/${extractRepoName(repoUrl)}`;
			const data = {
				repoUrl,
				sessionId,
				targetDir
			};
			if (options?.branch) data.branch = options.branch;
			if (options?.depth !== void 0) {
				if (!Number.isInteger(options.depth) || options.depth <= 0) throw new Error(`Invalid depth value: ${options.depth}. Must be a positive integer (e.g., 1, 5, 10).`);
				data.depth = options.depth;
			}
			const response = await this.post("/api/git/checkout", data);
			this.logSuccess("Repository cloned", `${repoUrl} (branch: ${response.branch}) -> ${response.targetDir}`);
			return response;
		} catch (error) {
			this.logError("checkout", error);
			throw error;
		}
	}
};

//#endregion
//#region src/clients/interpreter-client.ts
var InterpreterClient = class extends BaseHttpClient {
	maxRetries = 3;
	retryDelayMs = 1e3;
	async createCodeContext(options = {}) {
		return this.executeWithRetry(async () => {
			const response = await this.doFetch("/api/contexts", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify({
					language: options.language || "python",
					cwd: options.cwd || "/workspace",
					env_vars: options.envVars
				})
			});
			if (!response.ok) throw await this.parseErrorResponse(response);
			const data = await response.json();
			if (!data.success) throw new Error(`Failed to create context: ${JSON.stringify(data)}`);
			return {
				id: data.contextId,
				language: data.language,
				cwd: data.cwd || "/workspace",
				createdAt: new Date(data.timestamp),
				lastUsed: new Date(data.timestamp)
			};
		});
	}
	async runCodeStream(contextId, code, language, callbacks, timeoutMs) {
		return this.executeWithRetry(async () => {
			const stream = await this.doStreamFetch("/api/execute/code", {
				context_id: contextId,
				code,
				language,
				...timeoutMs !== void 0 && { timeout_ms: timeoutMs }
			});
			for await (const chunk of this.readLines(stream)) await this.parseExecutionResult(chunk, callbacks);
		});
	}
	async listCodeContexts() {
		return this.executeWithRetry(async () => {
			const response = await this.doFetch("/api/contexts", {
				method: "GET",
				headers: { "Content-Type": "application/json" }
			});
			if (!response.ok) throw await this.parseErrorResponse(response);
			const data = await response.json();
			if (!data.success) throw new Error(`Failed to list contexts: ${JSON.stringify(data)}`);
			return data.contexts.map((ctx) => ({
				id: ctx.id,
				language: ctx.language,
				cwd: ctx.cwd || "/workspace",
				createdAt: new Date(data.timestamp),
				lastUsed: new Date(data.timestamp)
			}));
		});
	}
	async deleteCodeContext(contextId) {
		return this.executeWithRetry(async () => {
			const response = await this.doFetch(`/api/contexts/${contextId}`, {
				method: "DELETE",
				headers: { "Content-Type": "application/json" }
			});
			if (!response.ok) throw await this.parseErrorResponse(response);
		});
	}
	/**
	* Get a raw stream for code execution.
	* Used by CodeInterpreter.runCodeStreaming() for direct stream access.
	*/
	async streamCode(contextId, code, language) {
		return this.doStreamFetch("/api/execute/code", {
			context_id: contextId,
			code,
			language
		});
	}
	/**
	* Execute an operation with automatic retry for transient errors
	*/
	async executeWithRetry(operation) {
		let lastError;
		for (let attempt = 0; attempt < this.maxRetries; attempt++) try {
			return await operation();
		} catch (error) {
			this.logError("executeWithRetry", error);
			lastError = error;
			if (this.isRetryableError(error)) {
				if (attempt < this.maxRetries - 1) {
					const delay = this.retryDelayMs * 2 ** attempt + Math.random() * 1e3;
					await new Promise((resolve) => setTimeout(resolve, delay));
					continue;
				}
			}
			throw error;
		}
		throw lastError || /* @__PURE__ */ new Error("Execution failed after retries");
	}
	isRetryableError(error) {
		if (error instanceof InterpreterNotReadyError) return true;
		if (error instanceof Error) return error.message.includes("not ready") || error.message.includes("initializing");
		return false;
	}
	async parseErrorResponse(response) {
		try {
			return createErrorFromResponse(await response.json());
		} catch {
			return createErrorFromResponse({
				code: ErrorCode.INTERNAL_ERROR,
				message: `HTTP ${response.status}: ${response.statusText}`,
				context: {},
				httpStatus: response.status,
				timestamp: (/* @__PURE__ */ new Date()).toISOString()
			});
		}
	}
	async *readLines(stream) {
		const reader = stream.getReader();
		let buffer = "";
		try {
			while (true) {
				const { done, value } = await reader.read();
				if (value) buffer += new TextDecoder().decode(value);
				if (done) break;
				let newlineIdx = buffer.indexOf("\n");
				while (newlineIdx !== -1) {
					yield buffer.slice(0, newlineIdx);
					buffer = buffer.slice(newlineIdx + 1);
					newlineIdx = buffer.indexOf("\n");
				}
			}
			if (buffer.length > 0) yield buffer;
		} finally {
			try {
				await reader.cancel();
			} catch {}
			reader.releaseLock();
		}
	}
	async parseExecutionResult(line, callbacks) {
		if (!line.trim()) return;
		if (!line.startsWith("data: ")) return;
		try {
			const jsonData = line.substring(6);
			const data = JSON.parse(jsonData);
			switch (data.type) {
				case "stdout":
					if (callbacks.onStdout && data.text) await callbacks.onStdout({
						text: data.text,
						timestamp: data.timestamp || Date.now()
					});
					break;
				case "stderr":
					if (callbacks.onStderr && data.text) await callbacks.onStderr({
						text: data.text,
						timestamp: data.timestamp || Date.now()
					});
					break;
				case "result":
					if (callbacks.onResult) {
						const result = new ResultImpl(data);
						await callbacks.onResult(result);
					}
					break;
				case "error":
					if (callbacks.onError) await callbacks.onError({
						name: data.ename || "Error",
						message: data.evalue || "Unknown error",
						traceback: data.traceback || []
					});
					break;
				case "execution_complete": break;
			}
		} catch (error) {
			this.logError("parseExecutionResult", error);
		}
	}
};

//#endregion
//#region src/clients/port-client.ts
/**
* Client for port management and preview URL operations
*/
var PortClient = class extends BaseHttpClient {
	/**
	* Expose a port and get a preview URL
	* @param port - Port number to expose
	* @param sessionId - The session ID for this operation
	* @param name - Optional name for the port
	*/
	async exposePort(port, sessionId, name) {
		try {
			const data = {
				port,
				sessionId,
				name
			};
			const response = await this.post("/api/expose-port", data);
			this.logSuccess("Port exposed", `${port} exposed at ${response.url}${name ? ` (${name})` : ""}`);
			return response;
		} catch (error) {
			this.logError("exposePort", error);
			throw error;
		}
	}
	/**
	* Unexpose a port and remove its preview URL
	* @param port - Port number to unexpose
	* @param sessionId - The session ID for this operation
	*/
	async unexposePort(port, sessionId) {
		try {
			const url = `/api/exposed-ports/${port}?session=${encodeURIComponent(sessionId)}`;
			const response = await this.delete(url);
			this.logSuccess("Port unexposed", `${port}`);
			return response;
		} catch (error) {
			this.logError("unexposePort", error);
			throw error;
		}
	}
	/**
	* Get all currently exposed ports
	* @param sessionId - The session ID for this operation
	*/
	async getExposedPorts(sessionId) {
		try {
			const url = `/api/exposed-ports?session=${encodeURIComponent(sessionId)}`;
			const response = await this.get(url);
			this.logSuccess("Exposed ports retrieved", `${response.ports.length} ports exposed`);
			return response;
		} catch (error) {
			this.logError("getExposedPorts", error);
			throw error;
		}
	}
	/**
	* Watch a port for readiness via SSE stream
	* @param request - Port watch configuration
	* @returns SSE stream that emits PortWatchEvent objects
	*/
	async watchPort(request) {
		try {
			const stream = await this.doStreamFetch("/api/port-watch", request);
			this.logSuccess("Port watch started", `port ${request.port}`);
			return stream;
		} catch (error) {
			this.logError("watchPort", error);
			throw error;
		}
	}
};

//#endregion
//#region src/clients/process-client.ts
/**
* Client for background process management
*/
var ProcessClient = class extends BaseHttpClient {
	/**
	* Start a background process
	* @param command - Command to execute as a background process
	* @param sessionId - The session ID for this operation
	* @param options - Optional settings (processId)
	*/
	async startProcess(command, sessionId, options) {
		try {
			const data = {
				command,
				sessionId,
				...options?.processId !== void 0 && { processId: options.processId },
				...options?.timeoutMs !== void 0 && { timeoutMs: options.timeoutMs },
				...options?.env !== void 0 && { env: options.env },
				...options?.cwd !== void 0 && { cwd: options.cwd },
				...options?.encoding !== void 0 && { encoding: options.encoding },
				...options?.autoCleanup !== void 0 && { autoCleanup: options.autoCleanup }
			};
			const response = await this.post("/api/process/start", data);
			this.logSuccess("Process started", `${command} (ID: ${response.processId})`);
			return response;
		} catch (error) {
			this.logError("startProcess", error);
			throw error;
		}
	}
	/**
	* List all processes (sandbox-scoped, not session-scoped)
	*/
	async listProcesses() {
		try {
			const response = await this.get(`/api/process/list`);
			this.logSuccess("Processes listed", `${response.processes.length} processes`);
			return response;
		} catch (error) {
			this.logError("listProcesses", error);
			throw error;
		}
	}
	/**
	* Get information about a specific process (sandbox-scoped, not session-scoped)
	* @param processId - ID of the process to retrieve
	*/
	async getProcess(processId) {
		try {
			const url = `/api/process/${processId}`;
			const response = await this.get(url);
			this.logSuccess("Process retrieved", `ID: ${processId}`);
			return response;
		} catch (error) {
			this.logError("getProcess", error);
			throw error;
		}
	}
	/**
	* Kill a specific process (sandbox-scoped, not session-scoped)
	* @param processId - ID of the process to kill
	*/
	async killProcess(processId) {
		try {
			const url = `/api/process/${processId}`;
			const response = await this.delete(url);
			this.logSuccess("Process killed", `ID: ${processId}`);
			return response;
		} catch (error) {
			this.logError("killProcess", error);
			throw error;
		}
	}
	/**
	* Kill all running processes (sandbox-scoped, not session-scoped)
	*/
	async killAllProcesses() {
		try {
			const response = await this.delete(`/api/process/kill-all`);
			this.logSuccess("All processes killed", `${response.cleanedCount} processes terminated`);
			return response;
		} catch (error) {
			this.logError("killAllProcesses", error);
			throw error;
		}
	}
	/**
	* Get logs from a specific process (sandbox-scoped, not session-scoped)
	* @param processId - ID of the process to get logs from
	*/
	async getProcessLogs(processId) {
		try {
			const url = `/api/process/${processId}/logs`;
			const response = await this.get(url);
			this.logSuccess("Process logs retrieved", `ID: ${processId}, stdout: ${response.stdout.length} chars, stderr: ${response.stderr.length} chars`);
			return response;
		} catch (error) {
			this.logError("getProcessLogs", error);
			throw error;
		}
	}
	/**
	* Stream logs from a specific process (sandbox-scoped, not session-scoped)
	* @param processId - ID of the process to stream logs from
	*/
	async streamProcessLogs(processId) {
		try {
			const url = `/api/process/${processId}/stream`;
			const stream = await this.doStreamFetch(url, void 0, "GET");
			this.logSuccess("Process log stream started", `ID: ${processId}`);
			return stream;
		} catch (error) {
			this.logError("streamProcessLogs", error);
			throw error;
		}
	}
};

//#endregion
//#region src/clients/utility-client.ts
/**
* Client for health checks and utility operations
*/
var UtilityClient = class extends BaseHttpClient {
	/**
	* Ping the sandbox to check if it's responsive
	*/
	async ping() {
		try {
			const response = await this.get("/api/ping");
			this.logSuccess("Ping successful", response.message);
			return response.message;
		} catch (error) {
			this.logError("ping", error);
			throw error;
		}
	}
	/**
	* Get list of available commands in the sandbox environment
	*/
	async getCommands() {
		try {
			const response = await this.get("/api/commands");
			this.logSuccess("Commands retrieved", `${response.count} commands available`);
			return response.availableCommands;
		} catch (error) {
			this.logError("getCommands", error);
			throw error;
		}
	}
	/**
	* Create a new execution session
	* @param options - Session configuration (id, env, cwd)
	*/
	async createSession(options) {
		try {
			const response = await this.post("/api/session/create", options);
			this.logSuccess("Session created", `ID: ${options.id}`);
			return response;
		} catch (error) {
			this.logError("createSession", error);
			throw error;
		}
	}
	/**
	* Delete an execution session
	* @param sessionId - Session ID to delete
	*/
	async deleteSession(sessionId) {
		try {
			const response = await this.post("/api/session/delete", { sessionId });
			this.logSuccess("Session deleted", `ID: ${sessionId}`);
			return response;
		} catch (error) {
			this.logError("deleteSession", error);
			throw error;
		}
	}
	/**
	* Get the container version
	* Returns the version embedded in the Docker image during build
	*/
	async getVersion() {
		try {
			const response = await this.get("/api/version");
			this.logSuccess("Version retrieved", response.version);
			return response.version;
		} catch (error) {
			this.logger.debug("Failed to get container version (may be old container)", { error });
			return "unknown";
		}
	}
};

//#endregion
//#region src/clients/sandbox-client.ts
/**
* Main sandbox client that composes all domain-specific clients
* Provides organized access to all sandbox functionality
*
* Supports two transport modes:
* - HTTP (default): Each request is a separate HTTP call
* - WebSocket: All requests multiplexed over a single connection
*
* WebSocket mode reduces sub-request count when running inside Workers/Durable Objects.
*/
var SandboxClient = class {
	commands;
	files;
	processes;
	ports;
	git;
	interpreter;
	utils;
	transport = null;
	constructor(options) {
		if (options.transportMode === "websocket" && options.wsUrl) this.transport = createTransport({
			mode: "websocket",
			wsUrl: options.wsUrl,
			baseUrl: options.baseUrl,
			logger: options.logger,
			stub: options.stub,
			port: options.port
		});
		const clientOptions = {
			baseUrl: "http://localhost:3000",
			...options,
			transport: this.transport ?? options.transport
		};
		this.commands = new CommandClient(clientOptions);
		this.files = new FileClient(clientOptions);
		this.processes = new ProcessClient(clientOptions);
		this.ports = new PortClient(clientOptions);
		this.git = new GitClient(clientOptions);
		this.interpreter = new InterpreterClient(clientOptions);
		this.utils = new UtilityClient(clientOptions);
	}
	/**
	* Get the current transport mode
	*/
	getTransportMode() {
		return this.transport?.getMode() ?? "http";
	}
	/**
	* Check if WebSocket is connected (only relevant in WebSocket mode)
	*/
	isWebSocketConnected() {
		return this.transport?.isConnected() ?? false;
	}
	/**
	* Connect WebSocket transport (no-op in HTTP mode)
	* Called automatically on first request, but can be called explicitly
	* to establish connection upfront.
	*/
	async connect() {
		if (this.transport) await this.transport.connect();
	}
	/**
	* Disconnect WebSocket transport (no-op in HTTP mode)
	* Should be called when the sandbox is destroyed.
	*/
	disconnect() {
		if (this.transport) this.transport.disconnect();
	}
};

//#endregion
//#region src/security.ts
/**
* Security utilities for URL construction and input validation
*
* This module contains critical security functions to prevent:
* - URL injection attacks
* - SSRF (Server-Side Request Forgery) attacks
* - DNS rebinding attacks
* - Host header injection
* - Open redirect vulnerabilities
*/
var SecurityError = class extends Error {
	constructor(message, code) {
		super(message);
		this.code = code;
		this.name = "SecurityError";
	}
};
/**
* Validates port numbers for sandbox services
* Only allows non-system ports to prevent conflicts and security issues
*/
function validatePort(port) {
	if (!Number.isInteger(port)) return false;
	if (port < 1024 || port > 65535) return false;
	if ([3e3, 8787].includes(port)) return false;
	return true;
}
/**
* Sanitizes and validates sandbox IDs for DNS compliance and security
* Only enforces critical requirements - allows maximum developer flexibility
*/
function sanitizeSandboxId(id) {
	if (!id || id.length > 63) throw new SecurityError("Sandbox ID must be 1-63 characters long.", "INVALID_SANDBOX_ID_LENGTH");
	if (id.startsWith("-") || id.endsWith("-")) throw new SecurityError("Sandbox ID cannot start or end with hyphens (DNS requirement).", "INVALID_SANDBOX_ID_HYPHENS");
	const reservedNames = [
		"www",
		"api",
		"admin",
		"root",
		"system",
		"cloudflare",
		"workers"
	];
	const lowerCaseId = id.toLowerCase();
	if (reservedNames.includes(lowerCaseId)) throw new SecurityError(`Reserved sandbox ID '${id}' is not allowed.`, "RESERVED_SANDBOX_ID");
	return id;
}
/**
* Validates language for code interpreter
* Only allows supported languages
*/
function validateLanguage(language) {
	if (!language) return;
	const supportedLanguages = [
		"python",
		"python3",
		"javascript",
		"js",
		"node",
		"typescript",
		"ts"
	];
	const normalized = language.toLowerCase();
	if (!supportedLanguages.includes(normalized)) throw new SecurityError(`Unsupported language '${language}'. Supported languages: python, javascript, typescript`, "INVALID_LANGUAGE");
}

//#endregion
//#region src/interpreter.ts
var CodeInterpreter = class {
	interpreterClient;
	contexts = /* @__PURE__ */ new Map();
	constructor(sandbox) {
		this.interpreterClient = sandbox.client.interpreter;
	}
	/**
	* Create a new code execution context
	*/
	async createCodeContext(options = {}) {
		validateLanguage(options.language);
		const context = await this.interpreterClient.createCodeContext(options);
		this.contexts.set(context.id, context);
		return context;
	}
	/**
	* Run code with optional context
	*/
	async runCode(code, options = {}) {
		let context = options.context;
		if (!context) {
			const language = options.language || "python";
			context = await this.getOrCreateDefaultContext(language);
		}
		const execution = new Execution(code, context);
		await this.interpreterClient.runCodeStream(context.id, code, options.language, {
			onStdout: (output) => {
				execution.logs.stdout.push(output.text);
				if (options.onStdout) return options.onStdout(output);
			},
			onStderr: (output) => {
				execution.logs.stderr.push(output.text);
				if (options.onStderr) return options.onStderr(output);
			},
			onResult: async (result) => {
				execution.results.push(new ResultImpl(result));
				if (options.onResult) return options.onResult(result);
			},
			onError: (error) => {
				execution.error = error;
				if (options.onError) return options.onError(error);
			}
		});
		return execution;
	}
	/**
	* Run code and return a streaming response
	*/
	async runCodeStream(code, options = {}) {
		let context = options.context;
		if (!context) {
			const language = options.language || "python";
			context = await this.getOrCreateDefaultContext(language);
		}
		return this.interpreterClient.streamCode(context.id, code, options.language);
	}
	/**
	* List all code contexts
	*/
	async listCodeContexts() {
		const contexts = await this.interpreterClient.listCodeContexts();
		for (const context of contexts) this.contexts.set(context.id, context);
		return contexts;
	}
	/**
	* Delete a code context
	*/
	async deleteCodeContext(contextId) {
		await this.interpreterClient.deleteCodeContext(contextId);
		this.contexts.delete(contextId);
	}
	async getOrCreateDefaultContext(language) {
		for (const context of this.contexts.values()) if (context.language === language) return context;
		return this.createCodeContext({ language });
	}
};

//#endregion
//#region src/request-handler.ts
async function proxyToSandbox(request, env) {
	const logger = createLogger({
		component: "sandbox-do",
		traceId: TraceContext.fromHeaders(request.headers) || TraceContext.generate(),
		operation: "proxy"
	});
	try {
		const url = new URL(request.url);
		const routeInfo = extractSandboxRoute(url);
		if (!routeInfo) return null;
		const { sandboxId, port, path, token } = routeInfo;
		const sandbox = getSandbox(env.Sandbox, sandboxId, { normalizeId: true });
		if (port !== 3e3) {
			if (!await sandbox.validatePortToken(port, token)) {
				logger.warn("Invalid token access blocked", {
					port,
					sandboxId,
					path,
					hostname: url.hostname,
					url: request.url,
					method: request.method,
					userAgent: request.headers.get("User-Agent") || "unknown"
				});
				return new Response(JSON.stringify({
					error: `Access denied: Invalid token or port not exposed`,
					code: "INVALID_TOKEN"
				}), {
					status: 404,
					headers: { "Content-Type": "application/json" }
				});
			}
		}
		if (request.headers.get("Upgrade")?.toLowerCase() === "websocket") return await sandbox.fetch(switchPort(request, port));
		let proxyUrl;
		if (port !== 3e3) proxyUrl = `http://localhost:${port}${path}${url.search}`;
		else proxyUrl = `http://localhost:3000${path}${url.search}`;
		const proxyRequest = new Request(proxyUrl, {
			method: request.method,
			headers: {
				...Object.fromEntries(request.headers),
				"X-Original-URL": request.url,
				"X-Forwarded-Host": url.hostname,
				"X-Forwarded-Proto": url.protocol.replace(":", ""),
				"X-Sandbox-Name": sandboxId
			},
			body: request.body,
			duplex: "half"
		});
		return await sandbox.containerFetch(proxyRequest, port);
	} catch (error) {
		logger.error("Proxy routing error", error instanceof Error ? error : new Error(String(error)));
		return new Response("Proxy routing error", { status: 500 });
	}
}
function extractSandboxRoute(url) {
	const subdomainMatch = url.hostname.match(/^(\d{4,5})-([^.-][^.]*?[^.-]|[^.-])-([a-z0-9_-]{16})\.(.+)$/);
	if (!subdomainMatch) return null;
	const portStr = subdomainMatch[1];
	const sandboxId = subdomainMatch[2];
	const token = subdomainMatch[3];
	subdomainMatch[4];
	const port = parseInt(portStr, 10);
	if (!validatePort(port)) return null;
	let sanitizedSandboxId;
	try {
		sanitizedSandboxId = sanitizeSandboxId(sandboxId);
	} catch (error) {
		return null;
	}
	if (sandboxId.length > 63) return null;
	return {
		port,
		sandboxId: sanitizedSandboxId,
		path: url.pathname || "/",
		token
	};
}
function isLocalhostPattern(hostname) {
	if (hostname.startsWith("[")) if (hostname.includes("]:")) return hostname.substring(0, hostname.indexOf("]:") + 1) === "[::1]";
	else return hostname === "[::1]";
	if (hostname === "::1") return true;
	const hostPart = hostname.split(":")[0];
	return hostPart === "localhost" || hostPart === "127.0.0.1" || hostPart === "0.0.0.0";
}

//#endregion
//#region src/sse-parser.ts
/**
* Server-Sent Events (SSE) parser for streaming responses
* Converts ReadableStream<Uint8Array> to typed AsyncIterable<T>
*/
/**
* Parse a ReadableStream of SSE events into typed AsyncIterable
* @param stream - The ReadableStream from fetch response
* @param signal - Optional AbortSignal for cancellation
*/
async function* parseSSEStream(stream, signal) {
	const reader = stream.getReader();
	const decoder = new TextDecoder();
	let buffer = "";
	try {
		while (true) {
			if (signal?.aborted) throw new Error("Operation was aborted");
			const { done, value } = await reader.read();
			if (done) break;
			buffer += decoder.decode(value, { stream: true });
			const lines = buffer.split("\n");
			buffer = lines.pop() || "";
			for (const line of lines) {
				if (line.trim() === "") continue;
				if (line.startsWith("data: ")) {
					const data = line.substring(6);
					if (data === "[DONE]" || data.trim() === "") continue;
					try {
						yield JSON.parse(data);
					} catch {}
				}
			}
		}
		if (buffer.trim() && buffer.startsWith("data: ")) {
			const data = buffer.substring(6);
			if (data !== "[DONE]" && data.trim()) try {
				yield JSON.parse(data);
			} catch {}
		}
	} finally {
		try {
			await reader.cancel();
		} catch {}
		reader.releaseLock();
	}
}
/**
* Helper to convert a Response with SSE stream directly to AsyncIterable
* @param response - Response object with SSE stream
* @param signal - Optional AbortSignal for cancellation
*/
async function* responseToAsyncIterable(response, signal) {
	if (!response.ok) throw new Error(`Response not ok: ${response.status} ${response.statusText}`);
	if (!response.body) throw new Error("No response body");
	yield* parseSSEStream(response.body, signal);
}
/**
* Create an SSE-formatted ReadableStream from an AsyncIterable
* (Useful for Worker endpoints that need to forward AsyncIterable as SSE)
* @param events - AsyncIterable of events
* @param options - Stream options
*/
function asyncIterableToSSEStream(events, options) {
	const encoder = new TextEncoder();
	const serialize = options?.serialize || JSON.stringify;
	return new ReadableStream({
		async start(controller) {
			try {
				for await (const event of events) {
					if (options?.signal?.aborted) {
						controller.error(/* @__PURE__ */ new Error("Operation was aborted"));
						break;
					}
					const sseEvent = `data: ${serialize(event)}\n\n`;
					controller.enqueue(encoder.encode(sseEvent));
				}
				controller.enqueue(encoder.encode("data: [DONE]\n\n"));
			} catch (error) {
				controller.error(error);
			} finally {
				controller.close();
			}
		},
		cancel() {}
	});
}

//#endregion
//#region src/storage-mount/errors.ts
/**
* Bucket mounting error classes
*
* These are SDK-side validation errors that follow the same pattern as SecurityError.
* They are thrown before any container interaction occurs.
*/
/**
* Base error for bucket mounting operations
*/
var BucketMountError = class extends Error {
	code;
	constructor(message, code = ErrorCode.BUCKET_MOUNT_ERROR) {
		super(message);
		this.name = "BucketMountError";
		this.code = code;
	}
};
/**
* Thrown when S3FS mount command fails
*/
var S3FSMountError = class extends BucketMountError {
	constructor(message) {
		super(message, ErrorCode.S3FS_MOUNT_ERROR);
		this.name = "S3FSMountError";
	}
};
/**
* Thrown when no credentials found in environment
*/
var MissingCredentialsError = class extends BucketMountError {
	constructor(message) {
		super(message, ErrorCode.MISSING_CREDENTIALS);
		this.name = "MissingCredentialsError";
	}
};
/**
* Thrown when bucket name, mount path, or options are invalid
*/
var InvalidMountConfigError = class extends BucketMountError {
	constructor(message) {
		super(message, ErrorCode.INVALID_MOUNT_CONFIG);
		this.name = "InvalidMountConfigError";
	}
};

//#endregion
//#region src/storage-mount/credential-detection.ts
/**
* Detect credentials for bucket mounting from environment variables
* Priority order:
* 1. Explicit options.credentials
* 2. Standard AWS env vars: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
* 3. Error: no credentials found
*
* @param options - Mount options
* @param envVars - Environment variables
* @returns Detected credentials
* @throws MissingCredentialsError if no credentials found
*/
function detectCredentials(options, envVars) {
	if (options.credentials) return options.credentials;
	const awsAccessKeyId = envVars.AWS_ACCESS_KEY_ID;
	const awsSecretAccessKey = envVars.AWS_SECRET_ACCESS_KEY;
	if (awsAccessKeyId && awsSecretAccessKey) return {
		accessKeyId: awsAccessKeyId,
		secretAccessKey: awsSecretAccessKey
	};
	throw new MissingCredentialsError("No credentials found. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables, or pass explicit credentials in options.");
}

//#endregion
//#region src/storage-mount/provider-detection.ts
/**
* Detect provider from endpoint URL using pattern matching
*/
function detectProviderFromUrl(endpoint) {
	try {
		const hostname = new URL(endpoint).hostname.toLowerCase();
		if (hostname.endsWith(".r2.cloudflarestorage.com")) return "r2";
		if (hostname.endsWith(".amazonaws.com") || hostname === "s3.amazonaws.com") return "s3";
		if (hostname === "storage.googleapis.com") return "gcs";
		return null;
	} catch {
		return null;
	}
}
/**
* Get s3fs flags for a given provider
*
* Based on s3fs-fuse wiki recommendations:
* https://github.com/s3fs-fuse/s3fs-fuse/wiki/Non-Amazon-S3
*/
function getProviderFlags(provider) {
	if (!provider) return ["use_path_request_style"];
	switch (provider) {
		case "r2": return ["nomixupload"];
		case "s3": return [];
		case "gcs": return [];
		default: return ["use_path_request_style"];
	}
}
/**
* Resolve s3fs options by combining provider defaults with user overrides
*/
function resolveS3fsOptions(provider, userOptions) {
	const providerFlags = getProviderFlags(provider);
	if (!userOptions || userOptions.length === 0) return providerFlags;
	const allFlags = [...providerFlags, ...userOptions];
	const flagMap = /* @__PURE__ */ new Map();
	for (const flag of allFlags) {
		const [flagName] = flag.split("=");
		flagMap.set(flagName, flag);
	}
	return Array.from(flagMap.values());
}

//#endregion
//#region src/version.ts
/**
* SDK version - automatically synchronized with package.json by Changesets
* This file is auto-updated by .github/changeset-version.ts during releases
* DO NOT EDIT MANUALLY - Changes will be overwritten on the next version bump
*/
const SDK_VERSION = "0.6.10";

//#endregion
//#region src/sandbox.ts
function getSandbox(ns, id, options) {
	const sanitizedId = sanitizeSandboxId(id);
	const effectiveId = options?.normalizeId ? sanitizedId.toLowerCase() : sanitizedId;
	const hasUppercase = /[A-Z]/.test(sanitizedId);
	if (!options?.normalizeId && hasUppercase) createLogger({ component: "sandbox-do" }).warn(`Sandbox ID "${sanitizedId}" contains uppercase letters, which causes issues with preview URLs (hostnames are case-insensitive). normalizeId will default to true in a future version to prevent this. Use lowercase IDs or pass { normalizeId: true } to prepare.`);
	const stub = getContainer(ns, effectiveId);
	stub.setSandboxName?.(effectiveId, options?.normalizeId);
	if (options?.baseUrl) stub.setBaseUrl(options.baseUrl);
	if (options?.sleepAfter !== void 0) stub.setSleepAfter(options.sleepAfter);
	if (options?.keepAlive !== void 0) stub.setKeepAlive(options.keepAlive);
	if (options?.containerTimeouts) stub.setContainerTimeouts(options.containerTimeouts);
	return Object.assign(stub, { wsConnect: connect(stub) });
}
function connect(stub) {
	return async (request, port) => {
		if (!validatePort(port)) throw new SecurityError(`Invalid or restricted port: ${port}. Ports must be in range 1024-65535 and not reserved.`);
		const portSwitchedRequest = switchPort(request, port);
		return await stub.fetch(portSwitchedRequest);
	};
}
var Sandbox = class extends Container {
	defaultPort = 3e3;
	sleepAfter = "10m";
	client;
	codeInterpreter;
	sandboxName = null;
	normalizeId = false;
	baseUrl = null;
	defaultSession = null;
	envVars = {};
	logger;
	keepAliveEnabled = false;
	activeMounts = /* @__PURE__ */ new Map();
	transport = "http";
	/**
	* Default container startup timeouts (conservative for production)
	* Based on Cloudflare docs: "Containers take several minutes to provision"
	*/
	DEFAULT_CONTAINER_TIMEOUTS = {
		instanceGetTimeoutMS: 3e4,
		portReadyTimeoutMS: 9e4,
		waitIntervalMS: 1e3
	};
	/**
	* Active container timeout configuration
	* Can be set via options, env vars, or defaults
	*/
	containerTimeouts = { ...this.DEFAULT_CONTAINER_TIMEOUTS };
	/**
	* Create a SandboxClient with current transport settings
	*/
	createSandboxClient() {
		return new SandboxClient({
			logger: this.logger,
			port: 3e3,
			stub: this,
			...this.transport === "websocket" && {
				transportMode: "websocket",
				wsUrl: "ws://localhost:3000/ws"
			}
		});
	}
	constructor(ctx, env) {
		super(ctx, env);
		const envObj = env;
		["SANDBOX_LOG_LEVEL", "SANDBOX_LOG_FORMAT"].forEach((key) => {
			if (envObj?.[key]) this.envVars[key] = String(envObj[key]);
		});
		this.containerTimeouts = this.getDefaultTimeouts(envObj);
		this.logger = createLogger({
			component: "sandbox-do",
			sandboxId: this.ctx.id.toString()
		});
		const transportEnv = envObj?.SANDBOX_TRANSPORT;
		if (transportEnv === "websocket") this.transport = "websocket";
		else if (transportEnv != null && transportEnv !== "http") this.logger.warn(`Invalid SANDBOX_TRANSPORT value: "${transportEnv}". Must be "http" or "websocket". Defaulting to "http".`);
		this.client = this.createSandboxClient();
		this.codeInterpreter = new CodeInterpreter(this);
		this.ctx.blockConcurrencyWhile(async () => {
			this.sandboxName = await this.ctx.storage.get("sandboxName") || null;
			this.normalizeId = await this.ctx.storage.get("normalizeId") || false;
			this.defaultSession = await this.ctx.storage.get("defaultSession") || null;
			this.keepAliveEnabled = await this.ctx.storage.get("keepAliveEnabled") || false;
			const storedTimeouts = await this.ctx.storage.get("containerTimeouts");
			if (storedTimeouts) this.containerTimeouts = {
				...this.containerTimeouts,
				...storedTimeouts
			};
		});
	}
	async setSandboxName(name, normalizeId) {
		if (!this.sandboxName) {
			this.sandboxName = name;
			this.normalizeId = normalizeId || false;
			await this.ctx.storage.put("sandboxName", name);
			await this.ctx.storage.put("normalizeId", this.normalizeId);
		}
	}
	async setBaseUrl(baseUrl) {
		if (!this.baseUrl) {
			this.baseUrl = baseUrl;
			await this.ctx.storage.put("baseUrl", baseUrl);
		} else if (this.baseUrl !== baseUrl) throw new Error("Base URL already set and different from one previously provided");
	}
	async setSleepAfter(sleepAfter) {
		this.sleepAfter = sleepAfter;
		this.renewActivityTimeout();
	}
	async setKeepAlive(keepAlive) {
		this.keepAliveEnabled = keepAlive;
		await this.ctx.storage.put("keepAliveEnabled", keepAlive);
		if (keepAlive) this.logger.info("KeepAlive mode enabled - container will stay alive until explicitly destroyed");
		else this.logger.info("KeepAlive mode disabled - container will timeout normally");
	}
	async setEnvVars(envVars) {
		this.envVars = {
			...this.envVars,
			...envVars
		};
		if (this.defaultSession) for (const [key, value] of Object.entries(envVars)) {
			const exportCommand = `export ${key}='${value.replace(/'/g, "'\\''")}'`;
			const result = await this.client.commands.execute(exportCommand, this.defaultSession);
			if (result.exitCode !== 0) throw new Error(`Failed to set ${key}: ${result.stderr || "Unknown error"}`);
		}
	}
	/**
	* RPC method to configure container startup timeouts
	*/
	async setContainerTimeouts(timeouts) {
		const validated = { ...this.containerTimeouts };
		if (timeouts.instanceGetTimeoutMS !== void 0) validated.instanceGetTimeoutMS = this.validateTimeout(timeouts.instanceGetTimeoutMS, "instanceGetTimeoutMS", 5e3, 3e5);
		if (timeouts.portReadyTimeoutMS !== void 0) validated.portReadyTimeoutMS = this.validateTimeout(timeouts.portReadyTimeoutMS, "portReadyTimeoutMS", 1e4, 6e5);
		if (timeouts.waitIntervalMS !== void 0) validated.waitIntervalMS = this.validateTimeout(timeouts.waitIntervalMS, "waitIntervalMS", 100, 5e3);
		this.containerTimeouts = validated;
		await this.ctx.storage.put("containerTimeouts", this.containerTimeouts);
		this.logger.debug("Container timeouts updated", this.containerTimeouts);
	}
	/**
	* Validate a timeout value is within acceptable range
	* Throws error if invalid - used for user-provided values
	*/
	validateTimeout(value, name, min, max) {
		if (typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value)) throw new Error(`${name} must be a valid finite number, got ${value}`);
		if (value < min || value > max) throw new Error(`${name} must be between ${min}-${max}ms, got ${value}ms`);
		return value;
	}
	/**
	* Get default timeouts with env var fallbacks and validation
	* Precedence: SDK defaults < Env vars < User config
	*/
	getDefaultTimeouts(env) {
		const parseAndValidate = (envVar, name, min, max) => {
			const defaultValue = this.DEFAULT_CONTAINER_TIMEOUTS[name];
			if (envVar === void 0) return defaultValue;
			const parsed = parseInt(envVar, 10);
			if (Number.isNaN(parsed)) {
				this.logger.warn(`Invalid ${name}: "${envVar}" is not a number. Using default: ${defaultValue}ms`);
				return defaultValue;
			}
			if (parsed < min || parsed > max) {
				this.logger.warn(`Invalid ${name}: ${parsed}ms. Must be ${min}-${max}ms. Using default: ${defaultValue}ms`);
				return defaultValue;
			}
			return parsed;
		};
		return {
			instanceGetTimeoutMS: parseAndValidate(getEnvString(env, "SANDBOX_INSTANCE_TIMEOUT_MS"), "instanceGetTimeoutMS", 5e3, 3e5),
			portReadyTimeoutMS: parseAndValidate(getEnvString(env, "SANDBOX_PORT_TIMEOUT_MS"), "portReadyTimeoutMS", 1e4, 6e5),
			waitIntervalMS: parseAndValidate(getEnvString(env, "SANDBOX_POLL_INTERVAL_MS"), "waitIntervalMS", 100, 5e3)
		};
	}
	async mountBucket(bucket, mountPath, options) {
		this.logger.info(`Mounting bucket ${bucket} to ${mountPath}`);
		this.validateMountOptions(bucket, mountPath, options);
		const provider = options.provider || detectProviderFromUrl(options.endpoint);
		this.logger.debug(`Detected provider: ${provider || "unknown"}`, { explicitProvider: options.provider });
		const credentials = detectCredentials(options, this.envVars);
		const passwordFilePath = this.generatePasswordFilePath();
		this.activeMounts.set(mountPath, {
			bucket,
			mountPath,
			endpoint: options.endpoint,
			provider,
			passwordFilePath,
			mounted: false
		});
		try {
			await this.createPasswordFile(passwordFilePath, bucket, credentials);
			await this.exec(`mkdir -p ${shellEscape(mountPath)}`);
			await this.executeS3FSMount(bucket, mountPath, options, provider, passwordFilePath);
			this.activeMounts.set(mountPath, {
				bucket,
				mountPath,
				endpoint: options.endpoint,
				provider,
				passwordFilePath,
				mounted: true
			});
			this.logger.info(`Successfully mounted bucket ${bucket} to ${mountPath}`);
		} catch (error) {
			await this.deletePasswordFile(passwordFilePath);
			this.activeMounts.delete(mountPath);
			throw error;
		}
	}
	/**
	* Manually unmount a bucket filesystem
	*
	* @param mountPath - Absolute path where the bucket is mounted
	* @throws InvalidMountConfigError if mount path doesn't exist or isn't mounted
	*/
	async unmountBucket(mountPath) {
		this.logger.info(`Unmounting bucket from ${mountPath}`);
		const mountInfo = this.activeMounts.get(mountPath);
		if (!mountInfo) throw new InvalidMountConfigError(`No active mount found at path: ${mountPath}`);
		try {
			await this.exec(`fusermount -u ${shellEscape(mountPath)}`);
			mountInfo.mounted = false;
			this.activeMounts.delete(mountPath);
		} finally {
			await this.deletePasswordFile(mountInfo.passwordFilePath);
		}
		this.logger.info(`Successfully unmounted bucket from ${mountPath}`);
	}
	/**
	* Validate mount options
	*/
	validateMountOptions(bucket, mountPath, options) {
		if (!options.endpoint) throw new InvalidMountConfigError("Endpoint is required. Provide the full S3-compatible endpoint URL.");
		try {
			new URL(options.endpoint);
		} catch (error) {
			throw new InvalidMountConfigError(`Invalid endpoint URL: "${options.endpoint}". Must be a valid HTTP(S) URL.`);
		}
		if (!/^[a-z0-9]([a-z0-9.-]{0,61}[a-z0-9])?$/.test(bucket)) throw new InvalidMountConfigError(`Invalid bucket name: "${bucket}". Bucket names must be 3-63 characters, lowercase alphanumeric, dots, or hyphens, and cannot start/end with dots or hyphens.`);
		if (!mountPath.startsWith("/")) throw new InvalidMountConfigError(`Mount path must be absolute (start with /): "${mountPath}"`);
		if (this.activeMounts.has(mountPath)) throw new InvalidMountConfigError(`Mount path "${mountPath}" is already in use by bucket "${this.activeMounts.get(mountPath)?.bucket}". Unmount the existing bucket first or use a different mount path.`);
	}
	/**
	* Generate unique password file path for s3fs credentials
	*/
	generatePasswordFilePath() {
		return `/tmp/.passwd-s3fs-${crypto.randomUUID()}`;
	}
	/**
	* Create password file with s3fs credentials
	* Format: bucket:accessKeyId:secretAccessKey
	*/
	async createPasswordFile(passwordFilePath, bucket, credentials) {
		const content = `${bucket}:${credentials.accessKeyId}:${credentials.secretAccessKey}`;
		await this.writeFile(passwordFilePath, content);
		await this.exec(`chmod 0600 ${shellEscape(passwordFilePath)}`);
		this.logger.debug(`Created password file: ${passwordFilePath}`);
	}
	/**
	* Delete password file
	*/
	async deletePasswordFile(passwordFilePath) {
		try {
			await this.exec(`rm -f ${shellEscape(passwordFilePath)}`);
			this.logger.debug(`Deleted password file: ${passwordFilePath}`);
		} catch (error) {
			this.logger.warn(`Failed to delete password file ${passwordFilePath}`, { error: error instanceof Error ? error.message : String(error) });
		}
	}
	/**
	* Execute S3FS mount command
	*/
	async executeS3FSMount(bucket, mountPath, options, provider, passwordFilePath) {
		const resolvedOptions = resolveS3fsOptions(provider, options.s3fsOptions);
		const s3fsArgs = [];
		s3fsArgs.push(`passwd_file=${passwordFilePath}`);
		s3fsArgs.push(...resolvedOptions);
		if (options.readOnly) s3fsArgs.push("ro");
		s3fsArgs.push(`url=${options.endpoint}`);
		const optionsStr = shellEscape(s3fsArgs.join(","));
		const mountCmd = `s3fs ${shellEscape(bucket)} ${shellEscape(mountPath)} -o ${optionsStr}`;
		this.logger.debug("Executing s3fs mount", {
			bucket,
			mountPath,
			provider,
			resolvedOptions
		});
		const result = await this.exec(mountCmd);
		if (result.exitCode !== 0) throw new S3FSMountError(`S3FS mount failed: ${result.stderr || result.stdout || "Unknown error"}`);
		this.logger.debug("Mount command executed successfully");
	}
	/**
	* Cleanup and destroy the sandbox container
	*/
	async destroy() {
		this.logger.info("Destroying sandbox container");
		this.client.disconnect();
		for (const [mountPath, mountInfo] of this.activeMounts.entries()) {
			if (mountInfo.mounted) try {
				this.logger.info(`Unmounting bucket ${mountInfo.bucket} from ${mountPath}`);
				await this.exec(`fusermount -u ${shellEscape(mountPath)}`);
				mountInfo.mounted = false;
			} catch (error) {
				const errorMsg = error instanceof Error ? error.message : String(error);
				this.logger.warn(`Failed to unmount bucket ${mountInfo.bucket} from ${mountPath}: ${errorMsg}`);
			}
			await this.deletePasswordFile(mountInfo.passwordFilePath);
		}
		await super.destroy();
	}
	onStart() {
		this.logger.debug("Sandbox started");
		this.checkVersionCompatibility().catch((error) => {
			this.logger.error("Version compatibility check failed", error instanceof Error ? error : new Error(String(error)));
		});
	}
	/**
	* Check if the container version matches the SDK version
	* Logs a warning if there's a mismatch
	*/
	async checkVersionCompatibility() {
		try {
			const sdkVersion = SDK_VERSION;
			const containerVersion = await this.client.utils.getVersion();
			if (containerVersion === "unknown") {
				this.logger.warn("Container version check: Container version could not be determined. This may indicate an outdated container image. Please update your container to match SDK version " + sdkVersion);
				return;
			}
			if (containerVersion !== sdkVersion) {
				const message = `Version mismatch detected! SDK version (${sdkVersion}) does not match container version (${containerVersion}). This may cause compatibility issues. Please update your container image to version ${sdkVersion}`;
				this.logger.warn(message);
			} else this.logger.debug("Version check passed", {
				sdkVersion,
				containerVersion
			});
		} catch (error) {
			this.logger.debug("Version compatibility check encountered an error", { error: error instanceof Error ? error.message : String(error) });
		}
	}
	async onStop() {
		this.logger.debug("Sandbox stopped");
		this.defaultSession = null;
		this.activeMounts.clear();
		await Promise.all([this.ctx.storage.delete("portTokens"), this.ctx.storage.delete("defaultSession")]);
	}
	onError(error) {
		this.logger.error("Sandbox error", error instanceof Error ? error : new Error(String(error)));
	}
	/**
	* Override Container.containerFetch to use production-friendly timeouts
	* Automatically starts container with longer timeouts if not running
	*/
	async containerFetch(requestOrUrl, portOrInit, portParam) {
		const { request, port } = this.parseContainerFetchArgs(requestOrUrl, portOrInit, portParam);
		if ((await this.getState()).status !== "healthy") try {
			this.logger.debug("Starting container with configured timeouts", {
				instanceTimeout: this.containerTimeouts.instanceGetTimeoutMS,
				portTimeout: this.containerTimeouts.portReadyTimeoutMS
			});
			await this.startAndWaitForPorts({
				ports: port,
				cancellationOptions: {
					instanceGetTimeoutMS: this.containerTimeouts.instanceGetTimeoutMS,
					portReadyTimeoutMS: this.containerTimeouts.portReadyTimeoutMS,
					waitInterval: this.containerTimeouts.waitIntervalMS,
					abort: request.signal
				}
			});
		} catch (e) {
			if (this.isNoInstanceError(e)) return new Response("Container is currently provisioning. This can take several minutes on first deployment. Please retry in a moment.", {
				status: 503,
				headers: { "Retry-After": "10" }
			});
			if (this.isTransientStartupError(e)) {
				this.logger.debug("Transient container startup error, returning 503", { error: e instanceof Error ? e.message : String(e) });
				return new Response("Container is starting. Please retry in a moment.", {
					status: 503,
					headers: { "Retry-After": "3" }
				});
			}
			this.logger.error("Container startup failed with permanent error", e instanceof Error ? e : new Error(String(e)));
			return new Response(`Failed to start container: ${e instanceof Error ? e.message : String(e)}`, { status: 500 });
		}
		return await super.containerFetch(requestOrUrl, portOrInit, portParam);
	}
	/**
	* Helper: Check if error is "no container instance available"
	* This indicates the container VM is still being provisioned.
	*/
	isNoInstanceError(error) {
		return error instanceof Error && error.message.toLowerCase().includes("no container instance");
	}
	/**
	* Helper: Check if error is a transient startup error that should trigger retry
	*
	* These errors occur during normal container startup and are recoverable:
	* - Port not yet mapped (container starting, app not listening yet)
	* - Connection refused (port mapped but app not ready)
	* - Timeouts during startup (recoverable with retry)
	* - Network transients (temporary connectivity issues)
	*
	* Errors NOT included (permanent failures):
	* - "no such image" - missing Docker image
	* - "container already exists" - name collision
	* - Configuration errors
	*/
	isTransientStartupError(error) {
		if (!(error instanceof Error)) return false;
		const msg = error.message.toLowerCase();
		return [
			"container port not found",
			"connection refused: container port",
			"the container is not listening",
			"failed to verify port",
			"container did not start",
			"network connection lost",
			"container suddenly disconnected",
			"monitor failed to find container",
			"timed out",
			"timeout",
			"the operation was aborted"
		].some((pattern) => msg.includes(pattern));
	}
	/**
	* Helper: Parse containerFetch arguments (supports multiple signatures)
	*/
	parseContainerFetchArgs(requestOrUrl, portOrInit, portParam) {
		let request;
		let port;
		if (requestOrUrl instanceof Request) {
			request = requestOrUrl;
			port = typeof portOrInit === "number" ? portOrInit : void 0;
		} else {
			const url = typeof requestOrUrl === "string" ? requestOrUrl : requestOrUrl.toString();
			const init = typeof portOrInit === "number" ? {} : portOrInit || {};
			port = typeof portOrInit === "number" ? portOrInit : typeof portParam === "number" ? portParam : void 0;
			request = new Request(url, init);
		}
		port ??= this.defaultPort;
		if (port === void 0) throw new Error("No port specified for container fetch");
		return {
			request,
			port
		};
	}
	/**
	* Override onActivityExpired to prevent automatic shutdown when keepAlive is enabled
	* When keepAlive is disabled, calls parent implementation which stops the container
	*/
	async onActivityExpired() {
		if (this.keepAliveEnabled) this.logger.debug("Activity expired but keepAlive is enabled - container will stay alive");
		else {
			this.logger.debug("Activity expired - stopping container");
			await super.onActivityExpired();
		}
	}
	async fetch(request) {
		const traceId = TraceContext.fromHeaders(request.headers) || TraceContext.generate();
		const requestLogger = this.logger.child({
			traceId,
			operation: "fetch"
		});
		const url = new URL(request.url);
		if (!this.sandboxName && request.headers.has("X-Sandbox-Name")) {
			const name = request.headers.get("X-Sandbox-Name");
			this.sandboxName = name;
			await this.ctx.storage.put("sandboxName", name);
		}
		const upgradeHeader = request.headers.get("Upgrade");
		const connectionHeader = request.headers.get("Connection");
		if (upgradeHeader?.toLowerCase() === "websocket" && connectionHeader?.toLowerCase().includes("upgrade")) try {
			requestLogger.debug("WebSocket upgrade requested", {
				path: url.pathname,
				port: this.determinePort(url)
			});
			return await super.fetch(request);
		} catch (error) {
			requestLogger.error("WebSocket connection failed", error instanceof Error ? error : new Error(String(error)), { path: url.pathname });
			throw error;
		}
		const port = this.determinePort(url);
		return await this.containerFetch(request, port);
	}
	wsConnect(request, port) {
		throw new Error("wsConnect must be called on the stub returned by getSandbox()");
	}
	determinePort(url) {
		const proxyMatch = url.pathname.match(/^\/proxy\/(\d+)/);
		if (proxyMatch) return parseInt(proxyMatch[1], 10);
		return 3e3;
	}
	/**
	* Ensure default session exists - lazy initialization
	* This is called automatically by all public methods that need a session
	*
	* The session ID is persisted to DO storage. On container restart, if the
	* container already has this session (from a previous instance), we sync
	* our state rather than failing on duplicate creation.
	*/
	async ensureDefaultSession() {
		const sessionId = `sandbox-${this.sandboxName || "default"}`;
		if (this.defaultSession === sessionId) return this.defaultSession;
		try {
			await this.client.utils.createSession({
				id: sessionId,
				env: this.envVars || {},
				cwd: "/workspace"
			});
			this.defaultSession = sessionId;
			await this.ctx.storage.put("defaultSession", sessionId);
			this.logger.debug("Default session initialized", { sessionId });
		} catch (error) {
			if (error instanceof SessionAlreadyExistsError) {
				this.logger.debug("Session exists in container but not in DO state, syncing", { sessionId });
				this.defaultSession = sessionId;
				await this.ctx.storage.put("defaultSession", sessionId);
			} else throw error;
		}
		return this.defaultSession;
	}
	async exec(command, options) {
		const session = await this.ensureDefaultSession();
		return this.execWithSession(command, session, options);
	}
	/**
	* Internal session-aware exec implementation
	* Used by both public exec() and session wrappers
	*/
	async execWithSession(command, sessionId, options) {
		const startTime = Date.now();
		const timestamp = (/* @__PURE__ */ new Date()).toISOString();
		try {
			if (options?.signal?.aborted) throw new Error("Operation was aborted");
			let result;
			if (options?.stream && options?.onOutput) result = await this.executeWithStreaming(command, sessionId, options, startTime, timestamp);
			else {
				const commandOptions = options && (options.timeout !== void 0 || options.env !== void 0 || options.cwd !== void 0) ? {
					timeoutMs: options.timeout,
					env: options.env,
					cwd: options.cwd
				} : void 0;
				const response = await this.client.commands.execute(command, sessionId, commandOptions);
				const duration = Date.now() - startTime;
				result = this.mapExecuteResponseToExecResult(response, duration, sessionId);
			}
			if (options?.onComplete) options.onComplete(result);
			return result;
		} catch (error) {
			if (options?.onError && error instanceof Error) options.onError(error);
			throw error;
		}
	}
	async executeWithStreaming(command, sessionId, options, startTime, timestamp) {
		let stdout = "";
		let stderr = "";
		try {
			const stream = await this.client.commands.executeStream(command, sessionId, {
				timeoutMs: options.timeout,
				env: options.env,
				cwd: options.cwd
			});
			for await (const event of parseSSEStream(stream)) {
				if (options.signal?.aborted) throw new Error("Operation was aborted");
				switch (event.type) {
					case "stdout":
					case "stderr":
						if (event.data) {
							if (event.type === "stdout") stdout += event.data;
							if (event.type === "stderr") stderr += event.data;
							if (options.onOutput) options.onOutput(event.type, event.data);
						}
						break;
					case "complete": {
						const duration = Date.now() - startTime;
						return {
							success: (event.exitCode ?? 0) === 0,
							exitCode: event.exitCode ?? 0,
							stdout,
							stderr,
							command,
							duration,
							timestamp,
							sessionId
						};
					}
					case "error": throw new Error(event.data || "Command execution failed");
				}
			}
			throw new Error("Stream ended without completion event");
		} catch (error) {
			if (options.signal?.aborted) throw new Error("Operation was aborted");
			throw error;
		}
	}
	mapExecuteResponseToExecResult(response, duration, sessionId) {
		return {
			success: response.success,
			exitCode: response.exitCode,
			stdout: response.stdout,
			stderr: response.stderr,
			command: response.command,
			duration,
			timestamp: response.timestamp,
			sessionId
		};
	}
	/**
	* Create a Process domain object from HTTP client DTO
	* Centralizes process object creation with bound methods
	* This eliminates duplication across startProcess, listProcesses, getProcess, and session wrappers
	*/
	createProcessFromDTO(data, sessionId) {
		return {
			id: data.id,
			pid: data.pid,
			command: data.command,
			status: data.status,
			startTime: typeof data.startTime === "string" ? new Date(data.startTime) : data.startTime,
			endTime: data.endTime ? typeof data.endTime === "string" ? new Date(data.endTime) : data.endTime : void 0,
			exitCode: data.exitCode,
			sessionId,
			kill: async (signal) => {
				await this.killProcess(data.id, signal);
			},
			getStatus: async () => {
				return (await this.getProcess(data.id))?.status || "error";
			},
			getLogs: async () => {
				const logs = await this.getProcessLogs(data.id);
				return {
					stdout: logs.stdout,
					stderr: logs.stderr
				};
			},
			waitForLog: async (pattern, timeout) => {
				return this.waitForLogPattern(data.id, data.command, pattern, timeout);
			},
			waitForPort: async (port, options) => {
				await this.waitForPortReady(data.id, data.command, port, options);
			},
			waitForExit: async (timeout) => {
				return this.waitForProcessExit(data.id, data.command, timeout);
			}
		};
	}
	/**
	* Wait for a log pattern to appear in process output
	*/
	async waitForLogPattern(processId, command, pattern, timeout) {
		const startTime = Date.now();
		const conditionStr = this.conditionToString(pattern);
		let collectedStdout = "";
		let collectedStderr = "";
		try {
			const existingLogs = await this.getProcessLogs(processId);
			collectedStdout = existingLogs.stdout;
			if (collectedStdout && !collectedStdout.endsWith("\n")) collectedStdout += "\n";
			collectedStderr = existingLogs.stderr;
			if (collectedStderr && !collectedStderr.endsWith("\n")) collectedStderr += "\n";
			const stdoutResult = this.matchPattern(existingLogs.stdout, pattern);
			if (stdoutResult) return stdoutResult;
			const stderrResult = this.matchPattern(existingLogs.stderr, pattern);
			if (stderrResult) return stderrResult;
		} catch (error) {
			this.logger.debug("Could not get existing logs, will stream", {
				processId,
				error: error instanceof Error ? error.message : String(error)
			});
		}
		const stream = await this.streamProcessLogs(processId);
		let timeoutId;
		let timeoutPromise;
		if (timeout !== void 0) {
			const remainingTime = timeout - (Date.now() - startTime);
			if (remainingTime <= 0) throw this.createReadyTimeoutError(processId, command, conditionStr, timeout);
			timeoutPromise = new Promise((_, reject) => {
				timeoutId = setTimeout(() => {
					reject(this.createReadyTimeoutError(processId, command, conditionStr, timeout));
				}, remainingTime);
			});
		}
		try {
			const streamProcessor = async () => {
				const DEBOUNCE_MS = 50;
				let lastCheckTime = 0;
				let pendingCheck = false;
				const checkPattern = () => {
					const stdoutResult = this.matchPattern(collectedStdout, pattern);
					if (stdoutResult) return stdoutResult;
					const stderrResult = this.matchPattern(collectedStderr, pattern);
					if (stderrResult) return stderrResult;
					return null;
				};
				for await (const event of parseSSEStream(stream)) {
					if (event.type === "stdout" || event.type === "stderr") {
						const data = event.data || "";
						if (event.type === "stdout") collectedStdout += data;
						else collectedStderr += data;
						pendingCheck = true;
						const now = Date.now();
						if (now - lastCheckTime >= DEBOUNCE_MS) {
							lastCheckTime = now;
							pendingCheck = false;
							const result = checkPattern();
							if (result) return result;
						}
					}
					if (event.type === "exit") {
						if (pendingCheck) {
							const result = checkPattern();
							if (result) return result;
						}
						throw this.createExitedBeforeReadyError(processId, command, conditionStr, event.exitCode ?? 1);
					}
				}
				if (pendingCheck) {
					const result = checkPattern();
					if (result) return result;
				}
				throw this.createExitedBeforeReadyError(processId, command, conditionStr, 0);
			};
			if (timeoutPromise) return await Promise.race([streamProcessor(), timeoutPromise]);
			return await streamProcessor();
		} finally {
			if (timeoutId) clearTimeout(timeoutId);
		}
	}
	/**
	* Wait for a port to become available (for process readiness checking)
	*/
	async waitForPortReady(processId, command, port, options) {
		const { mode = "http", path = "/", status = {
			min: 200,
			max: 399
		}, timeout, interval = 500 } = options ?? {};
		const conditionStr = mode === "http" ? `port ${port} (HTTP ${path})` : `port ${port} (TCP)`;
		const statusMin = typeof status === "number" ? status : status.min;
		const statusMax = typeof status === "number" ? status : status.max;
		const stream = await this.client.ports.watchPort({
			port,
			mode,
			path,
			statusMin,
			statusMax,
			processId,
			interval
		});
		let timeoutId;
		let timeoutPromise;
		if (timeout !== void 0) timeoutPromise = new Promise((_, reject) => {
			timeoutId = setTimeout(() => {
				reject(this.createReadyTimeoutError(processId, command, conditionStr, timeout));
			}, timeout);
		});
		try {
			const streamProcessor = async () => {
				for await (const event of parseSSEStream(stream)) switch (event.type) {
					case "ready": return;
					case "process_exited": throw this.createExitedBeforeReadyError(processId, command, conditionStr, event.exitCode ?? 1);
					case "error": throw new Error(event.error || "Port watch failed");
				}
				throw new Error("Port watch stream ended unexpectedly");
			};
			if (timeoutPromise) await Promise.race([streamProcessor(), timeoutPromise]);
			else await streamProcessor();
		} finally {
			if (timeoutId) clearTimeout(timeoutId);
			try {
				await stream.cancel();
			} catch {}
		}
	}
	/**
	* Wait for a process to exit
	* Returns the exit code
	*/
	async waitForProcessExit(processId, command, timeout) {
		const stream = await this.streamProcessLogs(processId);
		let timeoutId;
		let timeoutPromise;
		if (timeout !== void 0) timeoutPromise = new Promise((_, reject) => {
			timeoutId = setTimeout(() => {
				reject(this.createReadyTimeoutError(processId, command, "process exit", timeout));
			}, timeout);
		});
		try {
			const streamProcessor = async () => {
				for await (const event of parseSSEStream(stream)) if (event.type === "exit") return { exitCode: event.exitCode ?? 1 };
				throw new Error(`Process ${processId} stream ended unexpectedly without exit event`);
			};
			if (timeoutPromise) return await Promise.race([streamProcessor(), timeoutPromise]);
			return await streamProcessor();
		} finally {
			if (timeoutId) clearTimeout(timeoutId);
		}
	}
	/**
	* Match a pattern against text
	*/
	matchPattern(text, pattern) {
		if (typeof pattern === "string") {
			if (text.includes(pattern)) {
				const lines = text.split("\n");
				for (const line of lines) if (line.includes(pattern)) return { line };
				return { line: pattern };
			}
		} else {
			const safePattern = new RegExp(pattern.source, pattern.flags.replace("g", ""));
			const match = text.match(safePattern);
			if (match) {
				const lines = text.split("\n");
				for (const line of lines) {
					const lineMatch = line.match(safePattern);
					if (lineMatch) return {
						line,
						match: lineMatch
					};
				}
				return {
					line: match[0],
					match
				};
			}
		}
		return null;
	}
	/**
	* Convert a log pattern to a human-readable string
	*/
	conditionToString(pattern) {
		if (typeof pattern === "string") return `"${pattern}"`;
		return pattern.toString();
	}
	/**
	* Create a ProcessReadyTimeoutError
	*/
	createReadyTimeoutError(processId, command, condition, timeout) {
		return new ProcessReadyTimeoutError({
			code: ErrorCode.PROCESS_READY_TIMEOUT,
			message: `Process did not become ready within ${timeout}ms. Waiting for: ${condition}`,
			context: {
				processId,
				command,
				condition,
				timeout
			},
			httpStatus: 408,
			timestamp: (/* @__PURE__ */ new Date()).toISOString(),
			suggestion: `Check if your process outputs ${condition}. You can increase the timeout parameter.`
		});
	}
	/**
	* Create a ProcessExitedBeforeReadyError
	*/
	createExitedBeforeReadyError(processId, command, condition, exitCode) {
		return new ProcessExitedBeforeReadyError({
			code: ErrorCode.PROCESS_EXITED_BEFORE_READY,
			message: `Process exited with code ${exitCode} before becoming ready. Waiting for: ${condition}`,
			context: {
				processId,
				command,
				condition,
				exitCode
			},
			httpStatus: 500,
			timestamp: (/* @__PURE__ */ new Date()).toISOString(),
			suggestion: "Check process logs with getLogs() for error messages"
		});
	}
	async startProcess(command, options, sessionId) {
		try {
			const session = sessionId ?? await this.ensureDefaultSession();
			const requestOptions = {
				...options?.processId !== void 0 && { processId: options.processId },
				...options?.timeout !== void 0 && { timeoutMs: options.timeout },
				...options?.env !== void 0 && { env: options.env },
				...options?.cwd !== void 0 && { cwd: options.cwd },
				...options?.encoding !== void 0 && { encoding: options.encoding },
				...options?.autoCleanup !== void 0 && { autoCleanup: options.autoCleanup }
			};
			const response = await this.client.processes.startProcess(command, session, requestOptions);
			const processObj = this.createProcessFromDTO({
				id: response.processId,
				pid: response.pid,
				command: response.command,
				status: "running",
				startTime: /* @__PURE__ */ new Date(),
				endTime: void 0,
				exitCode: void 0
			}, session);
			if (options?.onStart) options.onStart(processObj);
			if (options?.onOutput || options?.onExit) this.startProcessCallbackStream(response.processId, options).catch(() => {});
			return processObj;
		} catch (error) {
			if (options?.onError && error instanceof Error) options.onError(error);
			throw error;
		}
	}
	/**
	* Start background streaming for process callbacks
	* Opens SSE stream to container and routes events to callbacks
	*/
	async startProcessCallbackStream(processId, options) {
		try {
			const stream = await this.client.processes.streamProcessLogs(processId);
			for await (const event of parseSSEStream(stream)) switch (event.type) {
				case "stdout":
					if (event.data && options.onOutput) options.onOutput("stdout", event.data);
					break;
				case "stderr":
					if (event.data && options.onOutput) options.onOutput("stderr", event.data);
					break;
				case "exit":
				case "complete":
					if (options.onExit) options.onExit(event.exitCode ?? null);
					return;
			}
		} catch (error) {
			if (options.onError && error instanceof Error) options.onError(error);
			this.logger.error("Background process streaming failed", error instanceof Error ? error : new Error(String(error)), { processId });
		}
	}
	async listProcesses(sessionId) {
		const session = sessionId ?? await this.ensureDefaultSession();
		return (await this.client.processes.listProcesses()).processes.map((processData) => this.createProcessFromDTO({
			id: processData.id,
			pid: processData.pid,
			command: processData.command,
			status: processData.status,
			startTime: processData.startTime,
			endTime: processData.endTime,
			exitCode: processData.exitCode
		}, session));
	}
	async getProcess(id, sessionId) {
		const session = sessionId ?? await this.ensureDefaultSession();
		const response = await this.client.processes.getProcess(id);
		if (!response.process) return null;
		const processData = response.process;
		return this.createProcessFromDTO({
			id: processData.id,
			pid: processData.pid,
			command: processData.command,
			status: processData.status,
			startTime: processData.startTime,
			endTime: processData.endTime,
			exitCode: processData.exitCode
		}, session);
	}
	async killProcess(id, signal, sessionId) {
		await this.client.processes.killProcess(id);
	}
	async killAllProcesses(sessionId) {
		return (await this.client.processes.killAllProcesses()).cleanedCount;
	}
	async cleanupCompletedProcesses(sessionId) {
		return 0;
	}
	async getProcessLogs(id, sessionId) {
		const response = await this.client.processes.getProcessLogs(id);
		return {
			stdout: response.stdout,
			stderr: response.stderr,
			processId: response.processId
		};
	}
	async execStream(command, options) {
		if (options?.signal?.aborted) throw new Error("Operation was aborted");
		const session = await this.ensureDefaultSession();
		return this.client.commands.executeStream(command, session, {
			timeoutMs: options?.timeout,
			env: options?.env,
			cwd: options?.cwd
		});
	}
	/**
	* Internal session-aware execStream implementation
	*/
	async execStreamWithSession(command, sessionId, options) {
		if (options?.signal?.aborted) throw new Error("Operation was aborted");
		return this.client.commands.executeStream(command, sessionId, {
			timeoutMs: options?.timeout,
			env: options?.env,
			cwd: options?.cwd
		});
	}
	/**
	* Stream logs from a background process as a ReadableStream.
	*/
	async streamProcessLogs(processId, options) {
		if (options?.signal?.aborted) throw new Error("Operation was aborted");
		return this.client.processes.streamProcessLogs(processId);
	}
	async gitCheckout(repoUrl, options) {
		const session = options?.sessionId ?? await this.ensureDefaultSession();
		return this.client.git.checkout(repoUrl, session, {
			branch: options?.branch,
			targetDir: options?.targetDir,
			depth: options?.depth
		});
	}
	async mkdir(path, options = {}) {
		const session = options.sessionId ?? await this.ensureDefaultSession();
		return this.client.files.mkdir(path, session, { recursive: options.recursive });
	}
	async writeFile(path, content, options = {}) {
		const session = options.sessionId ?? await this.ensureDefaultSession();
		return this.client.files.writeFile(path, content, session, { encoding: options.encoding });
	}
	async deleteFile(path, sessionId) {
		const session = sessionId ?? await this.ensureDefaultSession();
		return this.client.files.deleteFile(path, session);
	}
	async renameFile(oldPath, newPath, sessionId) {
		const session = sessionId ?? await this.ensureDefaultSession();
		return this.client.files.renameFile(oldPath, newPath, session);
	}
	async moveFile(sourcePath, destinationPath, sessionId) {
		const session = sessionId ?? await this.ensureDefaultSession();
		return this.client.files.moveFile(sourcePath, destinationPath, session);
	}
	async readFile(path, options = {}) {
		const session = options.sessionId ?? await this.ensureDefaultSession();
		return this.client.files.readFile(path, session, { encoding: options.encoding });
	}
	/**
	* Stream a file from the sandbox using Server-Sent Events
	* Returns a ReadableStream that can be consumed with streamFile() or collectFile() utilities
	* @param path - Path to the file to stream
	* @param options - Optional session ID
	*/
	async readFileStream(path, options = {}) {
		const session = options.sessionId ?? await this.ensureDefaultSession();
		return this.client.files.readFileStream(path, session);
	}
	async listFiles(path, options) {
		const session = await this.ensureDefaultSession();
		return this.client.files.listFiles(path, session, options);
	}
	async exists(path, sessionId) {
		const session = sessionId ?? await this.ensureDefaultSession();
		return this.client.files.exists(path, session);
	}
	async exposePort(port, options) {
		if (options.hostname.endsWith(".workers.dev")) throw new CustomDomainRequiredError({
			code: ErrorCode.CUSTOM_DOMAIN_REQUIRED,
			message: `Port exposure requires a custom domain. .workers.dev domains do not support wildcard subdomains required for port proxying.`,
			context: { originalError: options.hostname },
			httpStatus: 400,
			timestamp: (/* @__PURE__ */ new Date()).toISOString()
		});
		const sessionId = await this.ensureDefaultSession();
		await this.client.ports.exposePort(port, sessionId, options?.name);
		if (!this.sandboxName) throw new Error("Sandbox name not available. Ensure sandbox is accessed through getSandbox()");
		const token = this.generatePortToken();
		const tokens = await this.ctx.storage.get("portTokens") || {};
		tokens[port.toString()] = token;
		await this.ctx.storage.put("portTokens", tokens);
		return {
			url: this.constructPreviewUrl(port, this.sandboxName, options.hostname, token),
			port,
			name: options?.name
		};
	}
	async unexposePort(port) {
		if (!validatePort(port)) throw new SecurityError(`Invalid port number: ${port}. Must be between 1024-65535 and not reserved.`);
		const sessionId = await this.ensureDefaultSession();
		await this.client.ports.unexposePort(port, sessionId);
		const tokens = await this.ctx.storage.get("portTokens") || {};
		if (tokens[port.toString()]) {
			delete tokens[port.toString()];
			await this.ctx.storage.put("portTokens", tokens);
		}
	}
	async getExposedPorts(hostname) {
		const sessionId = await this.ensureDefaultSession();
		const response = await this.client.ports.getExposedPorts(sessionId);
		if (!this.sandboxName) throw new Error("Sandbox name not available. Ensure sandbox is accessed through getSandbox()");
		const tokens = await this.ctx.storage.get("portTokens") || {};
		return response.ports.map((port) => {
			const token = tokens[port.port.toString()];
			if (!token) throw new Error(`Port ${port.port} is exposed but has no token. This should not happen.`);
			return {
				url: this.constructPreviewUrl(port.port, this.sandboxName, hostname, token),
				port: port.port,
				status: port.status
			};
		});
	}
	async isPortExposed(port) {
		try {
			const sessionId = await this.ensureDefaultSession();
			return (await this.client.ports.getExposedPorts(sessionId)).ports.some((exposedPort) => exposedPort.port === port);
		} catch (error) {
			this.logger.error("Error checking if port is exposed", error instanceof Error ? error : new Error(String(error)), { port });
			return false;
		}
	}
	async validatePortToken(port, token) {
		if (!await this.isPortExposed(port)) return false;
		const storedToken = (await this.ctx.storage.get("portTokens") || {})[port.toString()];
		if (!storedToken) {
			this.logger.error("Port is exposed but has no token - bug detected", void 0, { port });
			return false;
		}
		return storedToken === token;
	}
	generatePortToken() {
		const array = new Uint8Array(12);
		crypto.getRandomValues(array);
		return btoa(String.fromCharCode(...array)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "").toLowerCase();
	}
	constructPreviewUrl(port, sandboxId, hostname, token) {
		if (!validatePort(port)) throw new SecurityError(`Invalid port number: ${port}. Must be between 1024-65535 and not reserved.`);
		const effectiveId = this.sandboxName || sandboxId;
		const hasUppercase = /[A-Z]/.test(effectiveId);
		if (!this.normalizeId && hasUppercase) throw new SecurityError(`Preview URLs require lowercase sandbox IDs. Your ID "${effectiveId}" contains uppercase letters.\n\nTo fix this:\n1. Create a new sandbox with: getSandbox(ns, "${effectiveId}", { normalizeId: true })\n2. This will create a sandbox with ID: "${effectiveId.toLowerCase()}"\n\nNote: Due to DNS case-insensitivity, IDs with uppercase letters cannot be used with preview URLs.`);
		const sanitizedSandboxId = sanitizeSandboxId(sandboxId).toLowerCase();
		if (isLocalhostPattern(hostname)) {
			const [host, portStr] = hostname.split(":");
			const mainPort = portStr || "80";
			try {
				const baseUrl = new URL(`http://${host}:${mainPort}`);
				baseUrl.hostname = `${port}-${sanitizedSandboxId}-${token}.${host}`;
				return baseUrl.toString();
			} catch (error) {
				throw new SecurityError(`Failed to construct preview URL: ${error instanceof Error ? error.message : "Unknown error"}`);
			}
		}
		try {
			const baseUrl = new URL(`https://${hostname}`);
			baseUrl.hostname = `${port}-${sanitizedSandboxId}-${token}.${hostname}`;
			return baseUrl.toString();
		} catch (error) {
			throw new SecurityError(`Failed to construct preview URL: ${error instanceof Error ? error.message : "Unknown error"}`);
		}
	}
	/**
	* Create isolated execution session for advanced use cases
	* Returns ExecutionSession with full sandbox API bound to specific session
	*/
	async createSession(options) {
		const sessionId = options?.id || `session-${Date.now()}`;
		const mergedEnv = {
			...this.envVars,
			...options?.env ?? {}
		};
		const envPayload = Object.keys(mergedEnv).length > 0 ? mergedEnv : void 0;
		await this.client.utils.createSession({
			id: sessionId,
			...envPayload && { env: envPayload },
			...options?.cwd && { cwd: options.cwd }
		});
		return this.getSessionWrapper(sessionId);
	}
	/**
	* Get an existing session by ID
	* Returns ExecutionSession wrapper bound to the specified session
	*
	* This is useful for retrieving sessions across different requests/contexts
	* without storing the ExecutionSession object (which has RPC lifecycle limitations)
	*
	* @param sessionId - The ID of an existing session
	* @returns ExecutionSession wrapper bound to the session
	*/
	async getSession(sessionId) {
		return this.getSessionWrapper(sessionId);
	}
	/**
	* Delete an execution session
	* Cleans up session resources and removes it from the container
	* Note: Cannot delete the default session. To reset the default session,
	* use sandbox.destroy() to terminate the entire sandbox.
	*
	* @param sessionId - The ID of the session to delete
	* @returns Result with success status, sessionId, and timestamp
	* @throws Error if attempting to delete the default session
	*/
	async deleteSession(sessionId) {
		if (this.defaultSession && sessionId === this.defaultSession) throw new Error(`Cannot delete default session '${sessionId}'. Use sandbox.destroy() to terminate the sandbox.`);
		const response = await this.client.utils.deleteSession(sessionId);
		return {
			success: response.success,
			sessionId: response.sessionId,
			timestamp: response.timestamp
		};
	}
	/**
	* Internal helper to create ExecutionSession wrapper for a given sessionId
	* Used by both createSession and getSession
	*/
	getSessionWrapper(sessionId) {
		return {
			id: sessionId,
			exec: (command, options) => this.execWithSession(command, sessionId, options),
			execStream: (command, options) => this.execStreamWithSession(command, sessionId, options),
			startProcess: (command, options) => this.startProcess(command, options, sessionId),
			listProcesses: () => this.listProcesses(sessionId),
			getProcess: (id) => this.getProcess(id, sessionId),
			killProcess: (id, signal) => this.killProcess(id, signal),
			killAllProcesses: () => this.killAllProcesses(),
			cleanupCompletedProcesses: () => this.cleanupCompletedProcesses(),
			getProcessLogs: (id) => this.getProcessLogs(id),
			streamProcessLogs: (processId, options) => this.streamProcessLogs(processId, options),
			writeFile: (path, content, options) => this.writeFile(path, content, {
				...options,
				sessionId
			}),
			readFile: (path, options) => this.readFile(path, {
				...options,
				sessionId
			}),
			readFileStream: (path) => this.readFileStream(path, { sessionId }),
			mkdir: (path, options) => this.mkdir(path, {
				...options,
				sessionId
			}),
			deleteFile: (path) => this.deleteFile(path, sessionId),
			renameFile: (oldPath, newPath) => this.renameFile(oldPath, newPath, sessionId),
			moveFile: (sourcePath, destPath) => this.moveFile(sourcePath, destPath, sessionId),
			listFiles: (path, options) => this.client.files.listFiles(path, sessionId, options),
			exists: (path) => this.exists(path, sessionId),
			gitCheckout: (repoUrl, options) => this.gitCheckout(repoUrl, {
				...options,
				sessionId
			}),
			setEnvVars: async (envVars) => {
				try {
					for (const [key, value] of Object.entries(envVars)) {
						const exportCommand = `export ${key}='${value.replace(/'/g, "'\\''")}'`;
						const result = await this.client.commands.execute(exportCommand, sessionId);
						if (result.exitCode !== 0) throw new Error(`Failed to set ${key}: ${result.stderr || "Unknown error"}`);
					}
				} catch (error) {
					this.logger.error("Failed to set environment variables", error instanceof Error ? error : new Error(String(error)), { sessionId });
					throw error;
				}
			},
			createCodeContext: (options) => this.codeInterpreter.createCodeContext(options),
			runCode: async (code, options) => {
				return (await this.codeInterpreter.runCode(code, options)).toJSON();
			},
			runCodeStream: (code, options) => this.codeInterpreter.runCodeStream(code, options),
			listCodeContexts: () => this.codeInterpreter.listCodeContexts(),
			deleteCodeContext: (contextId) => this.codeInterpreter.deleteCodeContext(contextId),
			mountBucket: (bucket, mountPath, options) => this.mountBucket(bucket, mountPath, options),
			unmountBucket: (mountPath) => this.unmountBucket(mountPath)
		};
	}
	async createCodeContext(options) {
		return this.codeInterpreter.createCodeContext(options);
	}
	async runCode(code, options) {
		return (await this.codeInterpreter.runCode(code, options)).toJSON();
	}
	async runCodeStream(code, options) {
		return this.codeInterpreter.runCodeStream(code, options);
	}
	async listCodeContexts() {
		return this.codeInterpreter.listCodeContexts();
	}
	async deleteCodeContext(contextId) {
		return this.codeInterpreter.deleteCodeContext(contextId);
	}
};

//#endregion
//#region src/file-stream.ts
/**
* Parse SSE (Server-Sent Events) lines from a stream
*/
async function* parseSSE(stream) {
	const reader = stream.getReader();
	const decoder = new TextDecoder();
	let buffer = "";
	try {
		while (true) {
			const { done, value } = await reader.read();
			if (done) break;
			buffer += decoder.decode(value, { stream: true });
			const lines = buffer.split("\n");
			buffer = lines.pop() || "";
			for (const line of lines) if (line.startsWith("data: ")) {
				const data = line.slice(6);
				try {
					yield JSON.parse(data);
				} catch {}
			}
		}
	} finally {
		try {
			await reader.cancel();
		} catch {}
		reader.releaseLock();
	}
}
/**
* Stream a file from the sandbox with automatic base64 decoding for binary files
*
* @param stream - The ReadableStream from readFileStream()
* @returns AsyncGenerator that yields FileChunk (string for text, Uint8Array for binary)
*
* @example
* ```ts
* const stream = await sandbox.readFileStream('/path/to/file.png');
* for await (const chunk of streamFile(stream)) {
*   if (chunk instanceof Uint8Array) {
*     // Binary chunk
*     console.log('Binary chunk:', chunk.length, 'bytes');
*   } else {
*     // Text chunk
*     console.log('Text chunk:', chunk);
*   }
* }
* ```
*/
async function* streamFile(stream) {
	let metadata = null;
	for await (const event of parseSSE(stream)) switch (event.type) {
		case "metadata":
			metadata = {
				mimeType: event.mimeType,
				size: event.size,
				isBinary: event.isBinary,
				encoding: event.encoding
			};
			break;
		case "chunk":
			if (!metadata) throw new Error("Received chunk before metadata");
			if (metadata.isBinary && metadata.encoding === "base64") {
				const binaryString = atob(event.data);
				const bytes = new Uint8Array(binaryString.length);
				for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
				yield bytes;
			} else yield event.data;
			break;
		case "complete":
			if (!metadata) throw new Error("Stream completed without metadata");
			return metadata;
		case "error": throw new Error(`File streaming error: ${event.error}`);
	}
	throw new Error("Stream ended unexpectedly");
}
/**
* Collect an entire file into memory from a stream
*
* @param stream - The ReadableStream from readFileStream()
* @returns Object containing the file content and metadata
*
* @example
* ```ts
* const stream = await sandbox.readFileStream('/path/to/file.txt');
* const { content, metadata } = await collectFile(stream);
* console.log('Content:', content);
* console.log('MIME type:', metadata.mimeType);
* ```
*/
async function collectFile(stream) {
	const chunks = [];
	const generator = streamFile(stream);
	let result = await generator.next();
	while (!result.done) {
		chunks.push(result.value);
		result = await generator.next();
	}
	const metadata = result.value;
	if (!metadata) throw new Error("Failed to get file metadata");
	if (metadata.isBinary) {
		const totalLength = chunks.reduce((sum, chunk) => sum + (chunk instanceof Uint8Array ? chunk.length : 0), 0);
		const combined = new Uint8Array(totalLength);
		let offset = 0;
		for (const chunk of chunks) if (chunk instanceof Uint8Array) {
			combined.set(chunk, offset);
			offset += chunk.length;
		}
		return {
			content: combined,
			metadata
		};
	} else return {
		content: chunks.filter((c) => typeof c === "string").join(""),
		metadata
	};
}

//#endregion
export { BucketMountError, CodeInterpreter, CommandClient, FileClient, GitClient, InvalidMountConfigError, MissingCredentialsError, PortClient, ProcessClient, ProcessExitedBeforeReadyError, ProcessReadyTimeoutError, S3FSMountError, Sandbox, SandboxClient, UtilityClient, asyncIterableToSSEStream, collectFile, getSandbox, isExecResult, isProcess, isProcessStatus, parseSSEStream, proxyToSandbox, responseToAsyncIterable, streamFile };
//# sourceMappingURL=index.js.map